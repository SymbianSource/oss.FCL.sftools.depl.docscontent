<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies) All rights reserved. -->
<!-- This component and the accompanying materials are made available under the terms of the License 
"Eclipse Public License v1.0" which accompanies this distribution, 
and is available at the URL "http://www.eclipse.org/legal/epl-v10.html". -->
<!-- Initial Contributors:
    Nokia Corporation - initial contribution.
Contributors: 
-->
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept xml:lang="en" id="GUID-E4D47AED-5FCA-535B-9B8B-3267A4CD01C2"><title>Allocation Strategy</title><prolog><metadata><keywords/></metadata></prolog><conbody><p>When building a chain of one or more Comms buffers to fulfil an allocation request, the pond uses the following rules: </p> <ul><li id="GUID-B09D8CAD-74E5-5A66-A066-4FFDB6E06A70"><p>First Rule: use the fewest Comms buffers possible </p> </li> <li id="GUID-B1732295-B9D6-5553-B04D-E1C688E2764C"><p>Second Rule: use the smallest Comms buffers that satisfy the request </p> </li> </ul> <p>With some of the <codeph>Alloc()</codeph> methods, you can specify size constraints for the buffer selection. You can define the minimum and maximum size of the Comms buffers in the chain, but there is a higher chance that the allocation will fail if there are no free buffers in the specified size range. </p> <p>The biggest block of contiguous memory has the size of the largest Comms buffer in the pond, as returned by <xref href="GUID-F5B96520-E8A6-3775-9059-DF5A1668043B.dita#GUID-F5B96520-E8A6-3775-9059-DF5A1668043B/GUID-AA451DD4-F367-3494-B646-FC9064568F92"><apiname>RCommsBufPond::LargestBufSize()</apiname></xref>. Requests for more memory than this value always return a chain of several Comms buffers. </p> <p>In the following example table, the pond has two pools, respectively containing 128-bytes and 1,500-bytes buffers. </p> <table id="GUID-C055F229-7833-528A-A95E-99E9C0DD9198"><tgroup cols="4"><colspec colname="col0"/><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry>Allocation request</entry> <entry>128-byte buffers</entry> <entry>1,500 byte buffers</entry> <entry>Motivation</entry> </row> </thead> <tbody><row><entry><p>3000 </p> </entry> <entry><p>0</p> </entry> <entry><p>2</p> </entry> <entry><p>First rule - fewer buffers than, for example, 24 128-byte buffers. </p> </entry> </row> <row><entry><p>1514 </p> </entry> <entry><p>1 </p> </entry> <entry><p>1</p> </entry> <entry><p>Second rule - Less memory than two 1,500-byte buffers. </p> </entry> </row> <row><entry><p>1500 </p> </entry> <entry><p>0</p> </entry> <entry><p>1</p> </entry> <entry><p>A buffer of the required size is available. </p> </entry> </row> <row><entry><p>1499 </p> </entry> <entry><p>0</p> </entry> <entry><p>1</p> </entry> <entry><p>First rule - Fewer buffers than 12 128-byte buffers. </p> </entry> </row> <row><entry><p>129 </p> </entry> <entry><p>0</p> </entry> <entry><p>1</p> </entry> <entry><p>First rule - Fewer buffers than two 128-byte buffers. </p> </entry> </row> <row><entry><p>128 </p> </entry> <entry><p>1 </p> </entry> <entry><p>0</p> </entry> <entry><p>A buffer of the required size is available. </p> </entry> </row> </tbody> </tgroup> </table> </conbody><related-links><link href="GUID-55E4D84B-1B90-5BA4-9CE0-6D26EA208F13.dita"><linktext>Overview</linktext> </link> <link href="GUID-B4F15CA3-CAD4-5A87-9610-A656CA337B72.dita"><linktext>Comms Buffers (MBuf)
                and Comms Chains</linktext> </link> <link href="GUID-F0891698-F714-55AA-A089-790BB0B07AE4.dita"><linktext>Allocation tutorial</linktext> </link> </related-links></concept>