<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies) All rights reserved. -->
<!-- This component and the accompanying materials are made available under the terms of the License 
"Eclipse Public License v1.0" which accompanies this distribution, 
and is available at the URL "http://www.eclipse.org/legal/epl-v10.html". -->
<!-- Initial Contributors:
    Nokia Corporation - initial contribution.
Contributors: 
-->
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="GUID-046E5E45-ADB1-54B7-8242-2B1DC5741640" xml:lang="en"><title>I2S Implementation
Guide</title><shortdesc>I2S (Integrated Interchip Sound) is a bus standard developed by
Philips to model the interface between producers and consumers of digital
audio data in a CPU-based system. </shortdesc><prolog><metadata><keywords/></metadata></prolog><conbody>
<section id="GUID-D2C1E08C-0D18-5AEF-B24C-6FC298A60DE9"><title>Required background</title> <p>Before
you start, you must: </p> <ul>
<li id="GUID-E2DF0243-A1D3-571E-9881-34731A2C222E"><p>understand platform
implementation, </p> </li>
<li id="GUID-370A5667-EE40-53D8-9C63-90FBD30ECD30"><p>understand I2S concepts
and terminology, </p> </li>
<li id="GUID-AF49BFB1-EB4A-59C8-8F27-469CCD49E222"><p>know the architecture
of the platform on which you are implementing, and </p> </li>
<li id="GUID-9485A6D5-681B-5415-920D-BD6ABC5A9D43"><p>understand the C++ signature
of the functions you are implementing. </p> </li>
</ul> </section>
<section id="GUID-4F05BE9F-C8C9-5F86-A1F9-0D52A528D92C"><title>Introduction</title> <p>You
can provide support for I2S hardware in a board support package by implementing
the interface that Symbian platform defines in the I2S class. To provide a
consistent interface to clients of the I2S class, your implementation must
return certain error codes in certain specified conditions. The details of
the functions, conditions and associated required return values are described
below. How your implementation of the functions communicates with your I2S
hardware will be specific to the hardware you are using. </p> </section>
<section id="GUID-D051D0F6-6028-4497-9A7B-6E6B4EAA86C4"><title>Procedure</title><p>Implement each function of class &lt;api-item&gt;I2S&lt;/api-item&gt;
with a return  value of </p> <ul id="GUID-353AF454-3EF4-5E15-A5DD-5FD09DE7DA01">
<li id="GUID-5B10AC1E-E9F5-5D62-8393-784CC4C53D9B"><p> <xref href="GUID-48BD3B2F-8C36-36EF-95A0-027029C2219F.dita"><apiname>KErrArgument</apiname></xref>, </p> </li>
<li id="GUID-52455A74-9BDA-5B27-A32B-10C9B8852318"><p> <xref href="GUID-48BD3B2F-8C36-36EF-95A0-027029C2219F.dita"><apiname>KErrNone</apiname></xref>, </p> </li>
<li id="GUID-641B3932-1742-5A44-87DA-E1F63C0714A6"><p> <xref href="GUID-48BD3B2F-8C36-36EF-95A0-027029C2219F.dita"><apiname>KErrNotSupported</apiname></xref>  </p> </li>
</ul><p>and other return values as specified for particular functions.</p><p>Implement
the following functions which are generic to I2S and do not  depend on access
mode. </p><ul>
<li><p>Implement each function of class <xref href="GUID-48BD3B2F-8C36-36EF-95A0-027029C2219F.dita"><apiname>I2S</apiname></xref> with a  return
value of <xref href="GUID-0BEA3647-7888-3612-A2D3-7E27AC405E29.dita"><apiname>KErrArgument</apiname></xref>. </p><p>The first argument of every
function is <codeph>aInterfaceId</codeph>  and represents the ID of an I2S
interface. If the passed-in ID is invalid, the   function should return <xref href="GUID-0BEA3647-7888-3612-A2D3-7E27AC405E29.dita"><apiname>KErrArgument</apiname></xref> without
further activity. </p></li>
<li><p>Implement <xref href="GUID-E6E8BD6D-70DA-3721-BABC-3935F1AD2C68.dita"><apiname>ConfigureInterface()</apiname></xref> with return  value <xref href="GUID-6CA4F1ED-7947-3087-B618-D35858FAA3BC.dita"><apiname>KErrNone</apiname></xref> for
each possible combination of interface role and interface type.</p><p>The
argument <codeph>aConfig</codeph> is a pointer to one or more  instances of <xref href="GUID-DE0D6A8E-A443-308F-B94F-2A0B7CBC1115.dita"><apiname>TI2sConfigBufV01</apiname></xref>.
 <xref href="GUID-DE0D6A8E-A443-308F-B94F-2A0B7CBC1115.dita"><apiname>TI2sConfigBufV01</apiname></xref> is a class of two members,  <xref href="GUID-623F019D-F088-320B-8EDB-79954E39B475.dita"><apiname>TI2sInterfaceRole</apiname></xref> and
  <xref href="GUID-A279FCD9-0D2A-33E2-817E-3408BE0E5407.dita"><apiname>TI2sInterfaceType</apiname></xref>. </p><p>The Symbian platform I2S interface
allows for any combination of the roles Master and Slave with the types Transmitter,
Receiver and Bidirectional.  The type Controller is also supported. You must
implement all the  configurations supported by the platform. </p><p>Implement <xref href="GUID-E6E8BD6D-70DA-3721-BABC-3935F1AD2C68.dita"><apiname>ConfigureInterface()</apiname></xref> with
return  value <xref href="GUID-F89DA3F0-2A48-3F9B-8F08-29350E92D0E4.dita"><apiname>KErrNotSupported</apiname></xref> for configurations not supported
on  the platform. </p></li>
<li><p> Implement <xref href="GUID-5FB8D2BF-EFC3-3C98-B874-170356322309.dita"><apiname>GetInterfaceConfiguration()</apiname></xref>. </p></li>
<li><p>Determine the current configuration of the interface and set  the argument <codeph>aConfig</codeph> to
that value.</p></li>
<li><p>Implement <xref href="GUID-08DA8564-840D-3EF7-B2D7-4542C69980EA.dita"><apiname>SetSamplingRate()</apiname></xref> with return value <xref href="GUID-6CA4F1ED-7947-3087-B618-D35858FAA3BC.dita"><apiname>KErrNone</apiname></xref> for
each value of the enumeration  <xref href="GUID-77E06AB9-F7D3-30AA-9B60-8DFC85FF915E.dita"><apiname>TI2sSamplingRate</apiname></xref>. </p><p>The
Symbian platform I2S interface supports sampling rates in the range  7.35KHz
to 96KHz as specified in <xref href="GUID-77E06AB9-F7D3-30AA-9B60-8DFC85FF915E.dita"><apiname>TI2sSamplingRate</apiname></xref>. If possible,
implement sampling for each of them. Where one of these sampling  rates is
not supported by the hardware, implement  <xref href="GUID-08DA8564-840D-3EF7-B2D7-4542C69980EA.dita"><apiname>SetSamplingRate()</apiname></xref> with
return value  <xref href="GUID-F89DA3F0-2A48-3F9B-8F08-29350E92D0E4.dita"><apiname>KErrNotSupported</apiname></xref>.</p></li>
<li><p>Implement <xref href="GUID-2485EA7C-0086-33F5-ADC1-18028E5D7A7A.dita"><apiname>GetSamplingRate()</apiname></xref>.  &lt;/para&gt; &lt;list
ordered="false"&gt;&lt;ls.item&gt;&lt;para ditatype="tutorialinfo"&gt;  Determine the
sampling rate and set the argument   <codeph>aSamplingRate</codeph> to that
value.</p></li>
<li><p>Implement <xref href="GUID-D36C99C0-7C53-3C47-8DE6-D5E2F6A4868D.dita"><apiname>SetFrameLengthAndFormat()</apiname></xref> for each  value
of the enumeration <xref href="GUID-F07687C5-09FF-3155-81D0-E8C19D19F550.dita"><apiname>TI2sFrameLength</apiname></xref> and.</p><p>Symbian platform
I2S interface supports the values specified in  <xref href="GUID-F07687C5-09FF-3155-81D0-E8C19D19F550.dita"><apiname>TI2sFrameLength</apiname></xref> for
lengths of frames in bits. The frame phases are not necessarily of equal length:
the API specifies that the  implementation shall calculate the length of the
right frame phase by subtracting the value of <codeph>aLeftFramePhaseLength</codeph> from
the value of  <codeph>aFrameLength</codeph>. If possible, implement frames
and phases to have all  the possible lengths supported by the interface. Where
a given length is not supported by the hardware, implement  <xref href="GUID-D36C99C0-7C53-3C47-8DE6-D5E2F6A4868D.dita"><apiname>SetFrameLengthAndFormat()</apiname></xref> with
return value  <xref href="GUID-F89DA3F0-2A48-3F9B-8F08-29350E92D0E4.dita"><apiname>KErrNotSupported</apiname></xref>.</p></li>
<li><p> Implement <xref href="GUID-4C3CE52D-579D-39D8-809B-5D24B4A6C612.dita"><apiname>GetFrameFormat()</apiname></xref>.</p></li>
<li><p>Determine the lengths of the left and right frame phases in bits and
set the arguments <codeph>aLeftFramePhaseLength</codeph> and  <codeph>aRightFramePhaseLength</codeph> to
those values.</p></li>
<li><p>Implement <xref href="GUID-1044E644-2D3A-35E6-8AA6-17484AC710DB.dita"><apiname>SetSampleLength()</apiname></xref> for each value of the
enumerations <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and  <xref href="GUID-AD2F9B40-C6D0-357A-8864-36889109932C.dita"><apiname>TI2sSampleLength</apiname></xref>. </p><p>The
length of the sample transmitted in a phase may be less than  the length of
the phase for reasons such as compression. You must therefore implement sample
length as an independent quantity: this will involve padding  the end of the
frame phase with appropriate values, usually 0. Where a given  combination
of phase and sample length is not supported by the hardware,  implement <xref href="GUID-B8DAE173-E262-30C0-8923-4446B1051EB8.dita"><apiname>SetSampleLength</apiname></xref> with
return value  <xref href="GUID-F89DA3F0-2A48-3F9B-8F08-29350E92D0E4.dita"><apiname>KErrNotSupported</apiname></xref>.</p></li>
<li><p>Implement <xref href="GUID-2550FD2D-2B62-3065-BD65-EB556E049F0A.dita"><apiname>GetSampleLength()</apiname></xref>.</p><p> For each value
of <codeph>TI2sFramePhase</codeph> determine the  sample length and set <codeph>aSampleLength</codeph> to
that value.</p></li>
<li><p> Implement <xref href="GUID-03D3853E-B659-35F8-9AED-9F4D49A56233.dita"><apiname>SetDelayCycles()</apiname></xref> for each value of the
enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p></li>
<li><p> Implement <xref href="GUID-03D3853E-B659-35F8-9AED-9F4D49A56233.dita"><apiname>SetDelayCycles()</apiname></xref> for each value of the
enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p> <p> The implementation
should delay the onset of the frame phase by the passed-in number of bit clock
cycles. The delay should apply to each frame until a new delay is specifed.
It may be necessary to reduce the frame length and truncate the sample.  </p> </li>
<li><p> Implement <xref href="GUID-9DB14B95-6153-3593-9D76-DE15A153BD45.dita"><apiname>GetDelayCycles()</apiname></xref> for each value of the
enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p> <p> Determine the number
of delay cycles for the frame phase and set the argument <codeph>aDelayCycles</codeph> to
that value.  </p> </li>
<li><p> Implement <xref href="GUID-6704FC78-E207-35F5-B690-E9B50622E9C4.dita"><apiname>Start()</apiname></xref> for each value of the enumeration <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.
 </p> <p> Implement the interface to start data transmission and data reception
in accordance with the argument <codeph>aDirection</codeph>, a bitmask of
values of <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>. If the interface is a Controller, <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref> should
be ignored. If the device is also a Master it should start generation of data
synchronisation signals.  </p> </li>
<li><p> Implement <xref href="GUID-7CBDCF0D-1D11-34D1-BF5C-1E5B50DA75B5.dita"><apiname>Stop()</apiname></xref> for each value of the enumeration <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.
 </p> <p> Implement the interface to stop data transmission and data reception
in accordance with the argument <codeph>aDirection</codeph>, a bitmask of
values of <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.  </p> </li>
<li><p> Implement <xref href="GUID-B381C742-3EC2-3B2B-8108-354807EA63C9.dita"><apiname>IsStarted()</apiname></xref> for each value of the enumeration <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.
 </p> <p> Determine whether a transmission or reception is under way. If so,
set the argument aStarted to <xref href="GUID-781E8158-805B-3784-8FED-D7A191822FC3.dita"><apiname>ETrue</apiname></xref>: otherwise set it to <xref href="GUID-A759CA2D-8327-348F-9337-4886E619D920.dita"><apiname>EFalse</apiname></xref>.
 </p> </li>
<li><p> Implement each of the following functions with a return value of <xref href="GUID-0BB03881-8862-35FC-8102-48A2932AB738.dita"><apiname>KErrInUse</apiname></xref>.
 </p> <p> For each function in the list, detemine whether the interface is
quiescent or a transfer is under way. If a transfer is under way, the functions
should return <xref href="GUID-0BB03881-8862-35FC-8102-48A2932AB738.dita"><apiname>KErrInUse</apiname></xref> without further activity.  </p> <ul>
<li><p>   <xref href="GUID-E6E8BD6D-70DA-3721-BABC-3935F1AD2C68.dita"><apiname>ConfigureInterface()</apiname></xref> </p> </li>
<li><p>   <xref href="GUID-08DA8564-840D-3EF7-B2D7-4542C69980EA.dita"><apiname>SetSamplingRate()</apiname></xref> </p> </li>
<li><p>   <xref href="GUID-D36C99C0-7C53-3C47-8DE6-D5E2F6A4868D.dita"><apiname>SetFrameLengthAndFormat()</apiname></xref> </p> </li>
<li><p>   <xref href="GUID-1044E644-2D3A-35E6-8AA6-17484AC710DB.dita"><apiname>SetSampleLength()</apiname></xref> </p> </li>
<li><p>   <xref href="GUID-C4E5C1C7-0261-3B92-81C9-6B6B02AE1646.dita"><apiname>SetCycleDelays()</apiname></xref> </p> </li>
<li><p>   <xref href="GUID-6704FC78-E207-35F5-B690-E9B50622E9C4.dita"><apiname>Start()</apiname></xref> </p> </li>
</ul></li>
</ul><ph>Implementing PIO</ph> <p> If the platform supports PIO access mode,
implement the following functions with a return value of <xref href="GUID-6CA4F1ED-7947-3087-B618-D35858FAA3BC.dita"><apiname>KErrNone</apiname></xref>:
otherwise implement them with a return value of <xref href="GUID-F89DA3F0-2A48-3F9B-8F08-29350E92D0E4.dita"><apiname>KErrNotSupported</apiname></xref>.
 </p> <ul>
<li><p> Implement <xref href="GUID-4987D177-B1CC-3C84-B164-A6A8C8A49D14.dita"><apiname>ReadReceiveRegister()</apiname></xref> for each value
of the enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p> <p> Implement
this function to read the contents of the register which receives data for
each frame phase and place the data in the argument <codeph>aData</codeph>.
 </p> <p> Implementation of this function depends on design decisions. If
a single register is used both to transmit and receive with half-duplex operation,
read data from that register. If a single register is used to hold the contents
of each frame phase, read data from that register, ignoring the argument <codeph>aFramePhase</codeph>.
In such cases it will be the responsibility of the user of the API to maintain
the integrity of the data, for instance by calling <xref href="GUID-34BD41A9-87DF-35E7-8961-FBBEB9907EE2.dita"><apiname>ReadRegisterModeStatus()</apiname></xref> to
determine which frame phase the data belongs to.  </p> </li>
<li><p> Implement <xref href="GUID-5D22BA8C-0A1D-3521-98B3-FEBDF2848173.dita"><apiname>WriteTransmitRegister()</apiname></xref> for each value
of the enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p> <p> Implement
this function to write the data in the argument <codeph>aData</codeph> to
the register which transmits data for each frame phase.  </p> <p> Implementation
of this function depends on design decisions. If a single register is used
both to transmit and receive with half-duplex operation, write data to that
register. If a single register is used to hold the contents of each frame
phase, write data to that register, ignoring the argument <codeph>aFramePhase</codeph>.
In such cases it will be the responsibility of the user of the API to maintain
the integrity of the data, for instance by calling <xref href="GUID-34BD41A9-87DF-35E7-8961-FBBEB9907EE2.dita"><apiname>ReadRegisterModeStatus()</apiname></xref> to
determine which frame phase the data belongs to.  </p> </li>
<li><p> Implement <xref href="GUID-D37567BB-A533-3E52-A683-7A2B55030437.dita"><apiname>ReadTransmitRegister()</apiname></xref> for each value
of the enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p> <p> Implement
this function to read the contents of the register which transmits data for
each frame phase and place the data in the argument <codeph>aData</codeph>.
 </p> <p> Implementation of this function depends on design decisions. If
a single register is used both to transmit and receive with half-duplex operation,
read data from that register. If a single register is used to hold the contents
of each frame phase, read data from that register, ignoring the argument <codeph>aFramePhase</codeph>.
In such cases it will be the responsibility of the user of the API to maintain
the integrity of the data, for instance by calling <xref href="GUID-34BD41A9-87DF-35E7-8961-FBBEB9907EE2.dita"><apiname>ReadRegisterModeStatus()</apiname></xref> to
determine which frame phase the data belongs to.  </p> </li>
<li><p> Implement <xref href="GUID-34BD41A9-87DF-35E7-8961-FBBEB9907EE2.dita"><apiname>ReadRegisterModeStatus()</apiname></xref> for each value
of the enumeration <xref href="GUID-BB325213-7BBA-3073-9D0E-6FB9700D5CC0.dita"><apiname>TI2sFlags</apiname></xref> and each value of the enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.
 </p> <p> Determine whether these conditions are true or false:  </p> <ul>
<li><p>   Receive register for the specified frame phase is full. </p> </li>
<li><p>   Transmit register for the specified frame phase is empty. </p> </li>
<li><p>   Receive register for the specified frame phase has overrun. </p> </li>
<li><p>   Transmit register for the specified frame phase has underrun.   </p> </li>
<li><p>   A framing error for the specified frame phase has occurred. </p> </li>
</ul> <p> Convert the values into a bitmask (1 means the condition is true)
and set the argument <codeph>aFlags</codeph> to that bitmask.  </p> </li>
<li><p> Implement <xref href="GUID-14D20C5A-1013-3438-9A05-F20E952BF714.dita"><apiname>EnableRegisterInterrupts()</apiname></xref> for each value
of the enumerations <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and <xref href="GUID-BB325213-7BBA-3073-9D0E-6FB9700D5CC0.dita"><apiname>TI2sFlags</apiname></xref>.
 </p> <p> Ensure that there is an interrupt for each interrupt flag in <xref href="GUID-BB325213-7BBA-3073-9D0E-6FB9700D5CC0.dita"><apiname>TI2sFlags</apiname></xref>.
Implement the interface to enable the interrupts in response to a bitmask
containing the interrupt flags: enable when the flag is set to 1. If there
are separate registers for each frame phase, implement the interrupts separately
for each frame phase which may be passed as <codeph>aFramePhase</codeph>:
otherwise ignore the argument <codeph>aFramePhase</codeph>.  </p> </li>
<li><p> Implement <xref href="GUID-C1DC5D07-E401-3553-8E4E-427976AF33DF.dita"><apiname>DisableRegisterInterrupts()</apiname></xref> for each
value of the enumerations <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and <xref href="GUID-BB325213-7BBA-3073-9D0E-6FB9700D5CC0.dita"><apiname>TI2sFlags</apiname></xref>.
 </p> <p> Ensure that there is an interrupt for each interrupt flag in <xref href="GUID-BB325213-7BBA-3073-9D0E-6FB9700D5CC0.dita"><apiname>TI2sFlags</apiname></xref>.
Implement the interface to disable the interrupts in response to a bitmask
containing the interrupt flags: disable when the flag is set to 1. If there
are separate registers for each frame phase, implement the interrupts separately
for each frame phase which may be passed as <codeph>aFramePhase</codeph>:
otherwise ignore the argument <codeph>aFramePhase</codeph>.  </p> </li>
<li><p> Implement <xref href="GUID-4E074F7C-78BD-3DB7-99B9-A7F71ED91276.dita"><apiname>IsRegisterInterruptEnabled()</apiname></xref> for each
value of the enumerations <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and <xref href="GUID-BB325213-7BBA-3073-9D0E-6FB9700D5CC0.dita"><apiname>TI2sFlags</apiname></xref>.
 </p> <p> Determine which interrupts are enabled for each frame phase and
convert the values to a bitmask. Set the argument <codeph>aEnabled</codeph> to
that bitmask.  </p> </li>
</ul><ph>Implementing FIFO</ph> <p> If the platform supports FIFO access mode,
implement the following functions with a return value of <xref href="GUID-6CA4F1ED-7947-3087-B618-D35858FAA3BC.dita"><apiname>KErrNone</apiname></xref>:
otherwise implement them with a return value of <xref href="GUID-F89DA3F0-2A48-3F9B-8F08-29350E92D0E4.dita"><apiname>KErrNotSupported</apiname></xref>.
 </p> <ul>
<li><p> Implement <xref href="GUID-F99D9D33-15C3-34A4-8035-4929E4721680.dita"><apiname>EnableFIFO()</apiname></xref> for each value of the enumerations <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.  </p> <p> Implement the ability to enable FIFO receive and transmit for
each direction, as passed in through the bitmask <codeph>aFifoMask</codeph>,
and frame phase. If the same FIFO is used for receive and transmit, ignore
the argument <codeph>aFifoMask</codeph>. If the same FIFO is used for both
frame phases, ignore the argument <codeph>aFramePhase</codeph>.  </p> </li>
<li><p> Implement <xref href="GUID-4137769C-6FB9-37EE-986F-677C313A87E7.dita"><apiname>DisableFIFO()</apiname></xref> for each value of the enumerations <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.  </p> <p> Implement the ability to disable FIFO receive and transmit for
each direction, as passed in through the bitmask <codeph>aFifoMask</codeph>,
and frame phase. If the same FIFO is used for receive and transmit, ignore
the argument <codeph>aFifoMask</codeph>. If the same FIFO is used for both
frame phases, ignore the argument <codeph>aFramePhase</codeph>.  </p> </li>
<li><p> Implement <xref href="GUID-1A4B3FFC-E74D-3046-96C6-6C10F136BFE0.dita"><apiname>IsFIFOEnabled()</apiname></xref> for each value of the
enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p> <p> Determine the enablement
status of the FIFOs for each value of the enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.
Convert the values into a bitmask and set the argument <codeph>aEnabled</codeph> to
it. If the same FIFO is used for both frame phases, ignore the argument <codeph>aFramePhase</codeph>.
 </p> </li>
<li><p> Implement <xref href="GUID-AAB7B832-99AD-34BF-9735-BEC3A975DA3C.dita"><apiname>SetFIFOThreshold()</apiname></xref> for each value of
the enumerations <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.
 </p> <p> Implement the interface to set the FIFO threshold to the value passed
through the argument <codeph>aThreshold</codeph>. If the same FIFO is used
for receive and transmit, ignore the argument <codeph>aFifoMask</codeph>.
If the same FIFO is used for both frame phases, ignore the argument <codeph>aFramePhase</codeph>.
 </p> </li>
<li><p> Implement <xref href="GUID-83E3305F-E8B0-39B5-B2DA-F18D1BDBC9DF.dita"><apiname>ReadFIFOModeStatus()</apiname></xref> for each value of
the enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p> <p> Determine the
status of the access modes for each frame phase. Convert the values into a
bitmask and set the argument <codeph>aFlags</codeph> to it. If the same FIFO
is used for both frame phases, ignore the argument <codeph>aFramePhase</codeph>.
 </p> </li>
<li><p> Implement <xref href="GUID-62D23B05-6C18-3091-A1DD-C93345A1EEDF.dita"><apiname>EnableFIFOInterrupts()</apiname></xref> for each value
of the enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p> <p> </p> <p> Ensure
that there is an interrupt for each interrupt flag in <xref href="GUID-BB325213-7BBA-3073-9D0E-6FB9700D5CC0.dita"><apiname>TI2sFlags</apiname></xref>.
Implement the interface to enable the interrupts in response to a bitmask
containing the interrupt flags: enable when the flag is set to 1. If there
are separate registers for each frame phase, implement the interrupts separately
for each frame phase which may be passed as <codeph>aFramePhase</codeph>:
otherwise ignore the argument <codeph>aFramePhase</codeph>.  </p> </li>
<li><p> Implement <xref href="GUID-97E2A18F-1696-3846-BE34-51A6D14A3162.dita"><apiname>DisableFIFOInterrupts()</apiname></xref> for each value
of the enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p> <p> Ensure that
there is an interrupt for each interrupt flag in <xref href="GUID-BB325213-7BBA-3073-9D0E-6FB9700D5CC0.dita"><apiname>TI2sFlags</apiname></xref>.
Implement the interface to disable the interrupts in response to a bitmask
containing the interrupt flags: disable when the flag is set to 1. If there
are separate registers for each frame phase, implement the interrupts separately
for each frame phase which may be passed as <codeph>aFramePhase</codeph>:
otherwise ignore the argument <codeph>aFramePhase</codeph>.  </p> </li>
<li><p> Implement <xref href="GUID-B46F5FC5-35DB-36A5-9746-1468F319B585.dita"><apiname>IsFIFOInterruptEnabled()</apiname></xref> for each value
of the enumeration <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref>.  </p> <p> Determine
which interrupts are enabled for each frame phase and convert the values to
a bitmask. Set the argument <codeph>aEnabled</codeph> to that bitmask.  </p> </li>
<li><p> Implement <xref href="GUID-A0B22E7D-ACAC-3AEE-BB0C-4F6C396924DC.dita"><apiname>ReadFIFOLevel()</apiname></xref> for each value of the
enumerations <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.
 </p> <p> Implement the interface to return the FIFO level for each pair of
values taken from <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.
For each pair of values passed as the arguments <codeph>aFramePhase</codeph> and <codeph>aDirection</codeph> write
the FIFO level to the argument <codeph>aLevel</codeph>.  </p> </li>
</ul> <required-cleanup translate="no"/><ph>Implementing DMA</ph> <p> If
the platform supports DMA access mode, implement the following functions with
a return value of <xref href="GUID-6CA4F1ED-7947-3087-B618-D35858FAA3BC.dita"><apiname>KErrNone</apiname></xref>: otherwise implement them with
a return value of <xref href="GUID-F89DA3F0-2A48-3F9B-8F08-29350E92D0E4.dita"><apiname>KErrNotSupported</apiname></xref>.  </p> <ul>
<li><p> Implement <xref href="GUID-6B21D414-C212-351E-B4CD-ADAAE5F7A691.dita"><apiname>EnableDMA()</apiname></xref> for each value of the enumerations <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.  </p> <p> Implement the ability to enable DMA receive and transmit for
each direction, as passed in through the bitmask <codeph>aFifoMask</codeph>,
and frame phase. If the same FIFO is used for receive and transmit, ignore
the argument <codeph>aFifoMask</codeph>. If the same FIFO is used for both
frame phases, ignore the argument <codeph>aFramePhase</codeph>.  </p> </li>
<li><p> Implement <xref href="GUID-3E449142-0447-394A-8C9C-C9BBEE4D61B6.dita"><apiname>DisableDMA()</apiname></xref> for each value of the enumerations <xref href="GUID-9E9EDBC3-31DC-3F0D-B944-658A42C34A3F.dita"><apiname>TI2sFramePhase</apiname></xref> and <xref href="GUID-692EA2DE-53E9-3323-B0BE-2ECEB077B400.dita"><apiname>TI2sDirection</apiname></xref>.  </p> <p> Implement the ability to disable DMA receive and transmit for
each direction, as passed in through the bitmask <codeph>aFifoMask</codeph>,
and frame phase. If the same FIFO is used for receive and transmit, ignore
the argument <codeph>aFifoMask</codeph>. If the same FIFO is used for both
frame phases, ignore the argument <codeph>aFramePhase</codeph>.  </p> </li>
<li><p> Implement <xref href="GUID-690D35E1-1B2F-339E-A080-D49205A1D5AA.dita"><apiname>IsDMAEnabled()</apiname></xref> for each value of the
enumeration <codeph>TI2sDirection</codeph>.  </p> <p> Determine the enablement
status of each FIFO and convert the values to a bitmask. Set the argument <codeph>aEnabled</codeph> to
that bitmask.  </p> </li>
</ul> </section>
</conbody><related-links>
<link href="GUID-B5A2D9BF-E4D0-52CB-AD19-1EC8B00F8F44.dita"><linktext>I2S Design
Considerations</linktext></link>
</related-links></concept>