<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies) All rights reserved. -->
<!-- This component and the accompanying materials are made available under the terms of the License 
"Eclipse Public License v1.0" which accompanies this distribution, 
and is available at the URL "http://www.eclipse.org/legal/epl-v10.html". -->
<!-- Initial Contributors:
    Nokia Corporation - initial contribution.
Contributors: 
-->
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39" xml:lang="en"><title>Migration
Tutorial: EKA1 Device Driver to Kernel Architecture 2</title><prolog><metadata><keywords/></metadata></prolog><conbody>
<p>Describes how to change a device driver written for the EKA1 kernel to
use the Kernel Architecture 2 device driver framework. </p>
<ul>
<li id="GUID-EF79D3E8-D9BC-5D96-BF99-53324DB75882"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-12934AF7-BB64-5520-9759-E4C3C1C05A3B">General points</xref>  </p> </li>
<li id="GUID-96CDB8AF-E3D3-5747-8F17-C9B0C00EB3E3"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-B96938A0-C87D-5583-A01E-9577EAAD8100">The user side interface</xref>  </p> <ul>
<li id="GUID-984B277B-A1CB-55E1-B4B8-C3FFC963FFB4"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-F76D6B1F-FCD3-5467-9500-F5A9644B6090">Changes to RBusLogicalChannel::DoCreate()</xref>  </p> </li>
<li id="GUID-E1C012D8-9628-59F4-8EB0-89DBEA78131C"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-49327709-D686-5365-9FA9-7E467F8C8975">Passing requests across to the kernel side</xref>  </p> </li>
</ul> </li>
<li id="GUID-BBAF2325-3F67-5AF3-B16B-855DD440B0A2"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-CF1E7996-2C86-51D7-AEF3-5DA2C7C88732">The LDD factory</xref>  </p> <ul>
<li id="GUID-A789D4B8-5B02-558E-8FFC-6622FEBCA9A5"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-11F8BFB5-E53D-55D8-9665-009D4469F21E">Changes to DLogicalDevice::Create()</xref>  </p> </li>
<li id="GUID-B1AC6555-1CAB-58BB-BB3E-973CEBD8F8F7"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-4F64E17F-B14F-5AAF-A7D2-A094DF137D5B">Creation of the LDD factory object</xref>  </p> </li>
<li id="GUID-77B9B05C-0129-553F-A0F6-9BB249CDA167"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-971523E6-F9F4-5091-97D0-FE5AC84FF2EC">Creating the logical channel</xref>  </p> </li>
</ul> </li>
<li id="GUID-5DAF0B07-2B0F-5D73-92A8-61F13F855C8E"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-0F2B1376-A4B4-5AA4-B07B-7E60A24D43D3">The logical channel</xref>  </p> <ul>
<li id="GUID-609E5FC6-B826-53BC-BB08-11A6F168F8C5"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-52EE0CF7-FAF7-5862-8CA3-6535DBF44094">Changes to the logical channel class</xref>  </p> </li>
<li id="GUID-DC164FE1-3D91-5BB5-A397-3EA5782222C9"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-F7CC6476-4B1E-52AA-A0E5-732BBA9DCAE1">Changes to DLogicalChannel::DoCreateL()</xref>  </p> </li>
<li id="GUID-09D3D62E-46B3-5070-86A8-AB64E604D64C"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-99587527-8E65-521A-A93D-C593C3DAD8B2">Moving code from DoControl(), DoCancel(), and DoRequest() to HandleMsg()</xref>  </p> </li>
</ul> </li>
<li id="GUID-119F2182-FCB8-5773-AB22-9DBA186DF710"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-18E141DC-98A7-5631-9458-E158DE475C19">The PDD factory</xref>  </p> <ul>
<li id="GUID-1BAE2D78-1E20-5F82-AB53-999769EDF272"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-27FCEF39-D8EA-5D4D-B897-D8932B7C2687">Changes to DPhysicalDevice::Create()</xref>  </p> </li>
<li id="GUID-B497F641-D128-5C82-AFFF-6FF28E190C3B"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-C35A9FD3-ECBB-556A-8EC6-5F26E6A233CE">Changes to DPhysicalDevice::Validate()</xref>  </p> </li>
<li id="GUID-48DDA6C7-EB25-55B4-9812-F43ECBA17843"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-D6EE15B9-DF83-5F49-9B2E-1325ACD860D7">Creation of the PDD factory object</xref>  </p> </li>
</ul> </li>
<li id="GUID-8222945F-C193-5296-A464-AD719580571C"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-09386854-74F8-598F-944B-D3C3F62F5C90">Interrupt handling</xref>  </p> </li>
<li id="GUID-3608CE36-BE96-52E5-9D9F-EE798856F708"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-4A7BCB91-C58B-597F-85B6-74463BE9BC04">Accessing User Memory</xref>  </p> </li>
<li id="GUID-9E453DBF-D6B9-5662-A7E8-A4EF95A6D478"><p> <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-073716F8-6567-5666-8E37-C6B690178EFC">Kernel-side code cannot link to EUSER.DLL</xref>  </p> </li>
</ul>
<section id="GUID-12934AF7-BB64-5520-9759-E4C3C1C05A3B"><title>General points</title> <p>The
device driver model has not changed substantially between EKA1 and EKA2. The
model is still based on the LDD and the PDD. EKA2 also keeps the idea of the
LDD factory, the logical channel, the PDD factory and the physical channel.
The changes are in the details. </p> <p>The big change is the way user-side
requests are routed and handled on the kernel side. The major innovation is
that requests from user-side clients can now be executed in the context of
a DFC running in a separate kernel-side thread (or DFCs in a number of separate
threads, if this is appropriate). This also means that code running kernel-side
can now block without halting the device as would have been the case in EKA1.
Indeed, the thread model can be as sophisticated as you need it to be. </p> <p>However,
EKA2 does provides a framework that makes it easier to port an EKA1 driver
to EKA2. The framework queues requests so that they run as DFCs in a single
thread. </p> <p>The details are described in <xref href="GUID-4A402DAD-99D3-595E-87FD-AAB5A970D6CC.dita">Writing
a device driver</xref>. This section highlights what's changed, and just as
important, <i>what has not changed</i>. </p> </section>
<section id="GUID-B96938A0-C87D-5583-A01E-9577EAAD8100"><title>The user side
interface</title> <p>In EKA2, the user side interface is the <xref href="GUID-6FBFA078-8253-3E24-B1F8-5F75E86C3066.dita"><apiname>RBusLogicalChannel</apiname></xref> class
as in EKA1. The interface is binary compatible with EKA1, but is not source
compatible. </p> <p>The <codeph>RBusLogicalChannel</codeph> object is still
a handle to a logical channel, and provides the functionality: to create a
logical channel, issue a synchronous request, issue an asynchronous request,
and cancel an asynchronous request. The member functions that do this are
still protected, in the C++ sense, and means that you still need to provide
a class derived from <codeph>RBusLogicalChannel</codeph> with "high-level"
functionality that you implement as calls to these <codeph>RBusLogicalChannel</codeph> protected
functions. </p> <p>In practice, it is highly unlikely that you need to change
your "high-level" user-side API. </p> <p id="GUID-F76D6B1F-FCD3-5467-9500-F5A9644B6090"><b>Changes to RBusLogicalChannel::DoCreate()</b> </p> <p>The
signature of the function that creates a logical channel has changed. </p> <p>In
EKA1: </p> <codeblock id="GUID-1423A59B-34FD-5990-9E02-DCF18AE9F7E2" xml:space="preserve">TInt DoCreate(const TDesC&amp; aDevice,const TVersion&amp; aVer,const TDesC* aChan,TInt aUnit,const TDesC* aDriver,const TDesC8* anInfo,TOwnerType aType=EOwnerProcess);</codeblock> <p>In EKA2, the function is inline: </p> <codeblock id="GUID-A79C7B0E-14AC-5DE4-BB5A-494BB26AE715" xml:space="preserve">TInt DoCreate(const TDesC&amp; aDevice, const TVersion&amp; aVer, TInt aUnit, const TDesC* aDriver, const TDesC8* anInfo, TOwnerType aType=EOwnerProcess, TBool aProtected=EFalse);</codeblock> <p>The <codeph>aChan</codeph> argument no longer exists in EKA2. This was
used in EKA1 to pass the name to be given to the logical channel object. The
name is now created by the device driver framework, and the user-side no longer
needs to supply one. When porting code from EKA1 to EKA2, the <codeph>aChan</codeph> argument
needs to be handled case by case. Usually this argument is not used, so it
can simply be omitted from the EKA2 version of the code. Where the name is
used in the EKA1 code, the code will need to be modified so as not to use
the name. </p> <p>In EKA2, there is an extra <codeph>aProtected</codeph> argument.
This provides a form of security. If set to true, the device is usable only
if the owner allows; if set to false, the object is usable by anyone. The
default value is: false; this makes ported code compatible with EKA1 behaviour. </p> <p id="GUID-49327709-D686-5365-9FA9-7E467F8C8975"><b>Passing requests across
to the kernel side</b> </p> <p>An important change is the way that requests
are encoded when passed from the user-side to the kernel side, and their interpretation
on the kernel-side. In EKA1, the kernel-side logical channel is a <codeph>DLogicalChannel</codeph> object.
In EKA2, it is <codeph>DLogicalChannelBase</codeph> object. </p> <p>The following
table summarises the functions that issue and handle requests once the logical
channel has been created. </p> <table id="GUID-1D3B6956-D526-5E65-A5B0-EB752811EBA4">
<tgroup cols="3"><colspec colname="col0"/><colspec colname="col1"/><colspec colname="col2"/>
<tbody>
<row>
<entry><p>User-side: RBusLogicalChannel </p> </entry>
<entry><p>EKA1: kernel-side: DLogicalChannel </p> </entry>
<entry><p>EKA2: kernel-side: DLogicalChannelBase </p> </entry>
</row>
<row>
<entry><p>DoControl() </p> </entry>
<entry><p>DoControl() </p> </entry>
<entry><p>Request() </p> </entry>
</row>
<row>
<entry><p>DoSvControl() </p> </entry>
<entry><p>DoControl() </p> </entry>
<entry><p>Request() </p> </entry>
</row>
<row>
<entry><p>DoRequest() </p> </entry>
<entry><p>DoRequest() </p> </entry>
<entry><p>Request() </p> </entry>
</row>
<row>
<entry><p>DoCancel() </p> </entry>
<entry><p>DoCancel() </p> </entry>
<entry><p>Request() </p> </entry>
</row>
</tbody>
</tgroup>
</table> <p>In EKA2, all user-side requests are now funnelled to the kernel
side into a single <codeph>Request()</codeph> function defined in <codeph>DLogicalChannelBase</codeph>. </p> <p>The
distinction between the <codeph>DoControl()</codeph> and <codeph>DoSvControl()</codeph> no
longer exists because any device driver call can allocate and free memory
on the kernel heap providing it either runs in the context of a kernel-side
thread or, if running in the context of a user-side thread, it enters a critical
section before performing the heap operation, by calling <xref href="GUID-3A3C08F3-3D33-3D9E-80E7-7855C7B21E02.dita#GUID-3A3C08F3-3D33-3D9E-80E7-7855C7B21E02/GUID-841D587C-E9E6-34EE-8ED0-E9A206F64379"><apiname>NKern::ThreadEnterCS()</apiname></xref>.
In EKA2, <codeph>DoControl()</codeph> and <codeph>DoSvControl()</codeph> are
the same. </p> <p>In EKA1, <codeph>DoControl()</codeph>, <codeph>DoSvControl()</codeph>, <codeph>DoRequest()</codeph> are
all prototyped to take a function number, and one or two optional parameters. <codeph>DoRequest()</codeph>,
in addition takes a <codeph>TRequestStatus</codeph> object, which is used
in the usual way to track the status of the asynchronous request. This remains
the same in EKA2, but, because all these functions now result in a call to
the single kernel-side <codeph>Request()</codeph> function, then the type
of the call has to be encoded. This is done by mangling the function number.
As in EKA1, <codeph>DoCancel()</codeph> still takes a bitmask that identifies
the asynchronous requests to be cancelled. </p> <table id="GUID-CA8D5F28-F013-5AFD-A422-622A8304BD43">
<tgroup cols="3"><colspec colname="col0"/><colspec colname="col1"/><colspec colname="col2"/>
<tbody>
<row>
<entry><p>user-side call </p> </entry>
<entry><p>translates to </p> </entry>
<entry><p>kernel-side call </p> </entry>
</row>
<row>
<entry><p>RBusLogicalChannel::DoControl(f, a1, a2) </p> </entry>
<entry><p> </p> </entry>
<entry><p>DLogicalChannelBase::Request(f, a1, a2) </p> </entry>
</row>
<row>
<entry><p>RBusLogicalChannel::DoSvControl(f, a1, a2) </p> </entry>
<entry><p> </p> </entry>
<entry><p>DLogicalChannelBase::Request(f, a1, a2) </p> </entry>
</row>
<row>
<entry><p>RBusLogicalChannel::DoRequest(f, s, a1, a2) </p> </entry>
<entry><p> </p> </entry>
<entry><p>DLogicalChannelBase::Request(~f, &amp;s, &amp;A) </p> </entry>
</row>
<row>
<entry><p>RBusLogicalChannel::DoCancel(m) </p> </entry>
<entry><p> </p> </entry>
<entry><p>DLogicalChannelBase::Request(0x7FFFFFFF, m, 0) </p> </entry>
</row>
</tbody>
</tgroup>
</table> <p>Where: </p> <ul>
<li id="GUID-9F6D9205-22BE-5EBB-B9C8-F0C25C01AA5F"><p> <codeph>f</codeph> is
a positive number that identifies the functionality; this can be the same
as your existing function number. </p> </li>
<li id="GUID-59A98A40-DB95-5E40-8B15-4356035E813B"><p> <codeph>a1</codeph> and <codeph>a2</codeph> are
optional parameters, represented as pointers to <codeph>TAny</codeph> types;
this is the same as in your existing code. </p> </li>
<li id="GUID-B005A4EF-81EC-5594-AB5A-55522BAF8235"><p> <codeph>A</codeph> is
a user-side stack based array containing the a1 and a2 members, and defined
as <codeph>TAny* a[2]</codeph>. </p> </li>
<li id="GUID-D25C656C-C0E1-5E21-92D2-CCBDDD54BFF2"><p> <codeph>~f</codeph> is
the bit-wise not value of <codeph>f</codeph>, effectively making it negative. </p> </li>
<li id="GUID-D9C8DA0C-753C-5EF9-A706-1B2C5C175FA4"><p> <codeph>m</codeph> is
is a bitmap that identifies all the asynchronous requests to be cancelled;
the meaning applied to this bit mask is the same as in EKA1, i.e. each bit
corresponds to an outstanding asynchronous request in a pattern that depends
on the device driver writer. </p> </li>
</ul> </section>
<section id="GUID-CF1E7996-2C86-51D7-AEF3-5DA2C7C88732"><title>The LDD factory</title> <p>In
EKA2, the LDD factory performs the same role as in EKA1. It is an instance
of a class derived from <xref href="GUID-7616AA05-83E6-3989-AB9D-11AE01245BEB.dita"><apiname>DLogicalDevice</apiname></xref>. </p> <p>Some general
changes: </p> <ul>
<li id="GUID-23A895D9-EF31-5505-9EA2-1EB0A1D753F0"><p>In EKA2, <codeph>DLogicalDevice</codeph> is
declared in <filepath>kernel.h</filepath>. This means that when declaring
your derived class, you need to <codeph>#include &lt;kernel.h&gt;</codeph> or
another header that includes this. In EKA1, the class is declared in <filepath>k32std.h</filepath>. </p> </li>
<li id="GUID-DB7EBE94-FA5B-526E-832C-DBF677F0188A"><p>In EKA2, <codeph>DLogicalDevice</codeph> is
derived from <codeph>DObject</codeph>. <codeph>DObject</codeph> is new in
EKA2, but has the same reference-counting behaviour as <codeph>CObject</codeph>.
The change is necessary because the kernel no longer has any dependency on
EUSER.DLL. In EKA1, <codeph>DLogicalDevice</codeph> is derived from <codeph>CObject</codeph>. </p> </li>
<li id="GUID-3F33A8D6-9562-5FB1-8046-8F28E0590875"><p>In EKA2, the <codeph>DLogicalDevice::Remove()</codeph> function
no longer exists. In EKA1, it is called by the kernel before <codeph>Close()</codeph> is
called on the factory object. In EKA2, the function is redundant. </p> </li>
<li id="GUID-14377D2A-8AC2-5277-8DB5-7584F4F7AF24"><p>The <codeph>DLogicalDevice::IsAvailable()</codeph> and <codeph>DLogicalDevice::QueryVersionSupported()</codeph> functions remain the same, both in signature and in meaning. </p> </li>
<li id="GUID-5A6A52D2-3791-5297-8198-62C7A838E968"><p> <codeph>DLogicalDevice::ChannelCreate()</codeph> and <codeph>DLogicalDevice::FindPhysicalDevice()</codeph> functions are new in EKA2, but they are not exported, and cannot be used
by device drivers. </p> </li>
<li id="GUID-7FE4F02C-2F45-52E6-AB21-B7CA5176370D"><p>The <codeph>DLogicalDevice::Library()</codeph> function
has been removed. The equivalent behaviour is now part of the Symbian OS internal
class <codeph>DCodeSeg</codeph>. </p> </li>
<li id="GUID-AA481BF1-CDE3-5BFC-8477-631D148AA4EB"><p>It is no longer necessary
to define a destructor. This is because because the function <codeph>DLogicalDevice::Remove()</codeph> is
no longer present. Although not strictly required, it may be still useful
to have some initialisation done by a default constructor, and this can be
copied from the EKA1 driver to the EKA2 driver. </p> </li>
</ul> <p id="GUID-11F8BFB5-E53D-55D8-9665-009D4469F21E"><b>Changes to DLogicalDevice::Create()</b> </p> <p>The
minimal declaration of your factory class derived from <codeph>DLogicalDevice</codeph> follows
the same general pattern in both EKA1 and EKA2; however there are some differences
to be noted. The following class declarations show the virtual functions that
are declared as pure virtual in the <codeph>DLogicalDevice</codeph> base class: </p> <p>In
EKA1: </p> <codeblock id="GUID-B3BC479B-E6F0-57E8-9512-6644983B5FC6" xml:space="preserve">class DTestFactory : public DLogicalDevice
    {
public:
    DTestFactory();
    virtual TInt Install();                    
    virtual void GetCaps(TDes8&amp; aDes) const;
    virtual DLogicalChannel* CreateL();
    ...
    };
      </codeblock> <p>In EKA2: </p> <codeblock id="GUID-03FFCA21-4A7A-5DAA-A4FB-3E2F79FB1408" xml:space="preserve">class DTestFactory : public DLogicalDevice
    {
public:
    DTestFactory();
    virtual TInt Install();
    virtual void GetCaps(TDes8&amp; aDes) const;
    virtual TInt Create(DLogicalChannelBase*&amp; aChannel);
    ...
    };
      </codeblock> <p>The <codeph>CreateL()</codeph> function has been renamed
to <codeph>Create()</codeph> because kernel-side functions can no longer use
the leave mechanism. This means that <codeph>Create()</codeph> now returns
a <codeph>TInt</codeph> value to report success or failure of the logical
channel creation operation. The pointer to the new logical channel object
is now returned though the <codeph>DLogicalChannelBase*</codeph> reference,
instead of being returned. </p> <p id="GUID-4F64E17F-B14F-5AAF-A7D2-A094DF137D5B"><b>Creation of the LDD factory
object</b> </p> <p>This still follows the same pattern as for EKA1. Creating
the factory object is still done through the first exported ordinal function.
The main difference is that you need to use the the macro: <codeph>DECLARE_STANDARD_LDD()</codeph> when
implementing your function. </p> <p>In EKA1: </p> <codeblock id="GUID-BC1E88EB-A536-5620-91A2-DAA2BC961D2D" xml:space="preserve">EXPORT_C DLogicalDevice* CreateLogicalDevice()
    {
    return new DTestFactory;
    }
      </codeblock> <p>In EKA2: </p> <codeblock id="GUID-23486233-3932-5686-B213-159E3736C78C" xml:space="preserve">DECLARE_STANDARD_LDD()
    {
    return new DTestFactory;
    }
      </codeblock> <p>You need to remove the <codeph>E32Dll()</codeph> function
from your existing code. The code generated by the <codeph>DECLARE_STANDARD_LDD()</codeph> macro,
effectively replaces it. </p> <p>If your driver is a kernel extension, then
you use <codeph>DECLARE_EXTENSION_LDD()</codeph> instead. </p> <p id="GUID-971523E6-F9F4-5091-97D0-FE5AC84FF2EC"><b>Creating the logical channel</b> </p> <p>The
EKA2 function, <codeph>DLogicalDevice::Create()</codeph>, for creating the
logical channel has a slightly changed implementation corresponding to the
change in signature. </p> <p>In EKA1: </p> <codeblock id="GUID-CB74C415-76E4-5D8F-AE12-4ECDC25B20A1" xml:space="preserve">DLogicalChannel* DTestFactory::CreateL()
    {
    return new(ELeave) DTest(this);
    }</codeblock> <p>In EKA2: </p> <codeblock id="GUID-73E7BBA2-B1AF-507B-9B37-B16970370664" xml:space="preserve">TInt DTestFactory::Create(DLogicalChannelBase*&amp; aChannel)
    {
    aChannel=new DTest;
    return aChannel?KErrNone:KErrNoMemory;
    }</codeblock> <p>Again note that kernel side functions cannot leave in
EKA2. </p> </section>
<section id="GUID-0F2B1376-A4B4-5AA4-B07B-7E60A24D43D3"><title>The logical
channel</title> <p>In EKA2, the logical channel is an instance of a class
derived from either <codeph>DLogicalChannelBase</codeph> or <codeph>DLogicalChannel</codeph>,
depending on the running model you want to use. </p> <p> <codeph> DLogicalChannel</codeph> is
derived from <codeph>DLogicalChannelBase</codeph> and provides an implementation
for the <codeph>Request()</codeph> function that is defined as pure virtual
in <codeph>DLogicalChannelBase</codeph>. </p> <p>In EKA2, all user side requests
are funnelled through the logical channel's <codeph>Request()</codeph> function,
which is called in the context of the user-side thread. <codeph>DLogicalChannel</codeph>'s
implementation of this function, provided by the device driver framework,
forms the basis of a ready-made mechanism that allows requests to be queued
and executed in the context of a kernel-side thread. The <codeph>DLogicalChannelBase</codeph> class
is an abstraction that allows you to implement your own mechanism for handling
requests. </p> <p>Note that there is no <codeph>DLogicalChannelBase</codeph> class
in EKA1. </p> <p>Some general points: </p> <ul>
<li id="GUID-8171A4E3-7462-5CC6-8A35-8218EC93110C"><p>In EKA2, <codeph>DLogicalChannel</codeph> and <codeph>DLogicalChannelBase</codeph> are
declared in <filepath>kernel.h</filepath>. This means that when declaring
your derived class, you need to <codeph>#include                 &lt;kernel.h&gt;</codeph> or
another header that includes it. In EKA1, the <codeph>DLogicalChannel</codeph> class
is declared in <filepath>k32std.h</filepath>. </p> </li>
<li id="GUID-2D986FAC-3E20-5486-B149-522133515CF4"><p>In EKA2, <codeph>DLogicalChannelBase</codeph> is
derived from <codeph>DObject</codeph>. <codeph>DObject</codeph> is new in
EKA2, but has the same reference-counting behaviour as <codeph>CObject</codeph>.
The change is necessary because the kernel no longer has any dependency on <filepath>EUSER.DLL</filepath>.
In EKA1, <codeph>DLogicalDevice</codeph> is derived from <codeph>CObject</codeph>. </p> </li>
<li id="GUID-1AAC6C35-7AED-55A9-8473-1FE1000D4112"><p> <codeph>DLogicalChannel</codeph> no
longer has a <codeph>DThread*                 iThread</codeph> data member.
This is because in EKA2, it is possible that more than one thread may be using
the device concurrently. The driver may still need to track client threads,
but this is up to the driver to implement. The current thread can be found
by calling <xref href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.dita#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D/GUID-65C45F57-EB58-3372-9C11-33C27811C0A2"><apiname>Kern::CurrentThread()</apiname></xref>. </p> </li>
<li id="GUID-8E8E30D9-00A4-5DA7-B9EE-A2F2BD2DE660"><p>In EKA2, there is no
function corresponding to EKA1's <codeph>DLogicalChannel::SetBehaviour()</codeph> function.
In EKA1, the function is used to define which (asynchronous) request numbers
are supported. In EKA2, the driver must include its own code to do this. </p> </li>
<li id="GUID-99BDEA56-59E0-5C9B-A6CF-09224EE1246B"><p>In EKA2, the device
driver framework does not provide specific support for dealing with request
status objects, i.e. <codeph>TRequestStatus</codeph> objects are not passed
from the user-side to the kernel-side. This means that the EKA1 <codeph>DLogicalChannel</codeph> array
of pointers to <codeph>TRequestStatus</codeph> objects, i.e. the protected
member: </p> <codeblock id="GUID-F7302B2F-D07E-59F7-AF6B-AB978B1A5473" xml:space="preserve">TRequestStatus *iRequestStatus[KMaxRequests];</codeblock> <p>no
longer exists in EKA2. The set of EKA1 <codeph>DLogicalChannel</codeph> member
functions named <codeph>Complete()</codeph> have also been removed. </p> <p>In
EKA2, asynchronous requests issued from the user-side still need to be signalled
as complete, and this must now be done explicitly by driver code. A pointer
to a user-side <codeph>TRequestStatus</codeph> object is passed when a request
is made. The driver code should just call <codeph>Kern::RequestComplete()</codeph> when
appropriate. The following code is the implementation of <codeph>HandleMsg()</codeph> taken
from the <xref href="GUID-9496B02E-D698-5C74-A8BE-3600AD56BBB3.dita">example driver</xref>,
and shows the request being completed when an attempt to start an asynchronous
request fails. </p> <p>This implementation of <codeph>HandleMsg()</codeph> is
identical for all nearly all LDDs and you can use it as a prototype for your
own LDDs. Differences between LDDs arise in the implementation of the <codeph>DoCancel()</codeph>, <codeph>DoRequest()</codeph> and <codeph>DoControl()</codeph> functions. These functions are called after parsing the message Id. </p> <codeblock id="GUID-B4D896C5-AC27-5410-AA60-4ECF402178FD" xml:space="preserve">void DDriver1Channel::HandleMsg(TMessageBase* aMsg)
    {
    TThreadMessage&amp; m=*(TThreadMessage*)aMsg;

    // Get message type
    TInt id=m.iValue;

    // Decode the message type and dispatch it to the relevent handler function...
    
    // A logical channel can be closed either explicitly by its user-side client,
    // or implicitly if the client thread dies. In the latter case, the channel
    // is closed in the context of the kernel supervisor thread. 

    if (id==(TInt)ECloseMsg)
        {
        // Channel Close
        DoCancel(RDriver1::EAllRequests);
        m.Complete(KErrNone, EFalse);
        return;
        }

    // For all other message types, we check that the message is from the thread
    // that created us.

    if(m.Client()!=iClient)
        {
        Kern::ThreadKill(m.Client(),EExitPanic,ERequestFromWrongThread,KDriver1PanicCategory);
        m.Complete(KErrNone,ETrue);
        return;
        }

    if (id==KMaxTInt)
        {
        // DoCancel
        DoCancel(m.Int0());
        m.Complete(KErrNone,ETrue);
        return;
        }

    if (id&lt;0)
        {
        // DoRequest
        TRequestStatus* pS=(TRequestStatus*)m.Ptr0();
        TInt r=DoRequest(~id,pS,m.Ptr1(),m.Ptr2());
        if (r!=KErrNone)
            Kern::RequestComplete(iClient,pS,r);
        m.Complete(KErrNone,ETrue);
        }
    else
        {
        // DoControl
        TInt r=DoControl(id,m.Ptr0(),m.Ptr1());
        m.Complete(r,ETrue);
        }
    }
</codeblock> <p> <codeph>iClient</codeph> is a <codeph>DThread*</codeph> type
defined in the derived class <codeph>DDriver1Channel</codeph>. This is intended
to point to the client thread's <codeph>DThread</codeph> object. It is set
to <codeph>&amp;Kern::CurrentThread()</codeph> in the driver's logical channel
constructor. Remember that the constructor is called in the context of the
client thread, and is implemented as follows: </p> <codeblock id="GUID-D337B120-6F1F-5A96-A8CF-E27593EDE360" xml:space="preserve">DDriver1Channel::DDriver1Channel()
    : iSendDataDfc(SendDataDfc, this, 1), // DFC is priority '1'
        iReceiveDataDfc(ReceiveDataDfc, this, 1) // DFC is priority '1'
    {
    // Get pointer to client threads DThread object
    iClient=&amp;Kern::CurrentThread();

    // Open a reference on client thread so it's control block can't disappear until
    // this driver has finished with it.
    // Note, this call to Open can't fail as it is being made in the thread that 
    // we are currently running in
    ((DObject*)iClient)-&gt;Open();
    }
</codeblock> <p>The destructor calls <codeph>Close()</codeph> on the client
thread to reduce the number of open references. It matches the open in the
constructor: </p> <codeblock id="GUID-38DCEECC-C578-5917-832F-9E2C05D7689B" xml:space="preserve">DDriver1Channel::~DDriver1Channel()
    {
    ...
    // Close our reference on the client thread
    Kern::SafeClose((DObject*&amp;)iClient,NULL);
    }
</codeblock> <p> <codeph>DLogicalChannel::IsPending()</codeph> no longer exists
in EKA2. </p> </li>
</ul> <p id="GUID-52EE0CF7-FAF7-5862-8CA3-6535DBF44094"><b>Changes to the logical channel
class</b> </p> <p>The declaration of your logical channel class depends on
how you intend to handle user-side requests. A large number of drivers will
use the device driver framework mechanism provided by <codeph>DLogicalChannel</codeph>,
and this is what we look at here. </p> <p>In EKA1, a typical logical channel
class would have been declared: </p> <codeblock id="GUID-3C85B299-99E6-5847-BEC5-87B89BAABD31" xml:space="preserve">class DTest : public DLogicalChannel
    {
public:
    DTest(DLogicalDevice* aLogicalDevice);
    ~DTest();
protected:
    virtual void DoCancel(TInt aReqNo);
    virtual void DoRequest(TInt aReqNo,TAny* a1,TAny* a2);
    virtual void DoCreateL(TInt aUnit,CBase* aPdd,const TDesC* anInfo,const TVersion&amp; aVer);
    virtual TInt DoControl(TInt aFunction,TAny *a1,TAny *a2);
public:
    ...
    };
</codeblock> <p>In EKA2, this simplifies to: </p> <codeblock id="GUID-23F96E88-9970-5CC0-B920-24F2749B580F" xml:space="preserve">class DTest : public DLogicalChannel
    {
public:
    DTest()
    ~DTest();
    virtual ~DTest();
    virtual TInt DoCreate(TInt aUnit, const TDesC8* anInfo, const TVersion&amp; aVer);
    virtual void HandleMsg(TMessageBase* aMsg);
    ...
    }
</codeblock> <p id="GUID-F7CC6476-4B1E-52AA-A0E5-732BBA9DCAE1"><b>Changes to DLogicalChannel::DoCreateL()</b> </p> <p>In
EKA1, the function <codeph>DoCreateL()</codeph>, that performs second stage
construction of the logical channel, is declared in <codeph>DLogicalChannel</codeph> with
the signature: </p> <codeblock id="GUID-79457A3C-F679-56B2-A4C3-5DD5555234B0" xml:space="preserve">virtual void DoCreateL(TInt aUnit,CBase *aDriver,const TDesC *anInfo,const TVersion &amp;aVer);</codeblock> <p>In EKA2, it is declared in <codeph>DLogicalChannelBase</codeph> and the
signature changes to: </p> <codeblock id="GUID-ADF1591E-3272-5F81-B5BF-6F89D6CB204B" xml:space="preserve">virtual TInt DoCreate(TInt aUnit, const TDesC8* anInfo, const TVersion&amp; aVer);</codeblock> <p>The 'L' signifies a function that can leave. The <codeph>DoCreateL()</codeph> function
has been renamed to <codeph>DoCreate()</codeph> because kernel-side functions
can no longer use the leave mechanism. This means that <codeph>DoCreate()</codeph> now
returns a <codeph>TInt</codeph> value to report success or failure of the
operation. For example, a typical implementation changes: </p> <p>from EKA1: </p> <codeblock id="GUID-E37FFCEC-C871-50EE-85A1-BC82A8548EBD" xml:space="preserve">void DTest::DoCreateL(TInt /*aUnit*/,CBase* /*aPdd*/,const TDesC* anInfo,const TVersion&amp; aVer)
    {
    if (!User::QueryVersionSupported(TVersion(KMajorVersionNumber, KMinorVersionNumber, KBuildVersionNumber), aVer))
        User::Leave(KErrNotSupported);
    ... // main body of function
    }
</codeblock> <p>to EKA2: </p> <codeblock id="GUID-CCFBA311-B354-5E7E-992D-B966ECAA2CB4" xml:space="preserve">TInt DTest::DoCreate(TInt /*aUnit*/, const TDesC8* anInfo, const TVersion&amp; aVer)
    {
    if (!Kern::QueryVersionSupported(TVersion(KMajorVersionNumber, KMinorVersionNumber, KBuildVersionNumber), aVer))
        return KErrNotSupported;
    ... // main body of function
    return KErrNone;
    }
</codeblock> <p>Note also the change from using <codeph>User::QueryVersionSupported()</codeph>,
which is now user-side only, to using <codeph>Kern::QueryVersionSupported()</codeph>,
the kernel-side equivalent. </p> <p id="GUID-99587527-8E65-521A-A93D-C593C3DAD8B2"><b>Moving code from DoControl(),
DoCancel(), and DoRequest() to HandleMsg()</b> </p> <p>The functionality provided
in EKA1 by the functions <codeph>DoControl()</codeph> handling a synchronous
request, <codeph>DoRequest()</codeph> handling an asynchronous request, and <codeph>DoCancel()</codeph> cancelling
an asynchronous request has now been replaced by a single call to <codeph>Request()</codeph> in
EKA2, as we saw in <xref href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.dita#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39/GUID-B96938A0-C87D-5583-A01E-9577EAAD8100">the
user side interface</xref>. </p> <p> <codeph>Request()</codeph> is defined
in <codeph>DLogicalChannelBase</codeph> as pure virtual, but an implementation
is provided by the <codeph>DLogicalChannel</codeph> class, which provides
a ready-made framework for turning requests into messages to be dealt with
by the appropriate DFC running in a single kernel-side thread. </p> <p> <codeph>Request()</codeph> uses
the message handling mechanism to send a message containing the request information
to the DFC running in the kernel-side thread. This calls <codeph>HandleMsg()</codeph>,
defined as pure virtual in <codeph>DLogicalChannel</codeph>, and implemented
by your own logical channel class. </p> <p>This means that the functionality
in your <codeph>DoControl()</codeph>, <codeph>DoCancel()</codeph>, and <codeph>DoRequest()</codeph> functions
effectively migrates to your implementation of <codeph>HandleMsg()</codeph>. <i>However</i>,
it is still useful to break this down into discrete functions; a typical way
to deal with this is to use a switch statement on the function number, and
then to route the call to these other functions as appropriate. These other
functions can, of course be called <codeph>DoControl()</codeph>, <codeph>DoCancel()</codeph>,
and <codeph>DoRequest()</codeph>, if you wish, but the names are no longer
mandated by the device driver framework. </p> <p>Also note that in using this
framework, the functionality now runs as a DFC in a kernel-side thread. </p> <fig id="GUID-DFBBC0A8-228C-5F3B-9558-3232219FD79C">
<image href="GUID-5AF59F75-E6AA-5364-903E-DFBBCD68D7FA_d0e303469_href.png" placement="inline"/>
</fig> </section>
<section id="GUID-18E141DC-98A7-5631-9458-E158DE475C19"><title>The PDD factory</title> <p>In
EKA2, the PDD factory performs the same role as in EKA1. It is an instance
of a class derived from <xref href="GUID-A5484A7F-94B9-34C7-9F88-82B1BF516930.dita"><apiname>DPhysicalDevice</apiname></xref>. </p> <p>Some general
changes: </p> <ul>
<li id="GUID-1F71249F-010E-5CF2-93B3-ECF9391315F3"><p>In EKA2, <codeph>DPhysicalDevice</codeph> is
declared in <filepath>kernel.h</filepath>. This means that when declaring
your derived class, you need to <codeph>#include &lt;kernel.h&gt;</codeph> or
another header that includes this. In EKA1, the class is declared in <filepath>k32std.h</filepath>. </p> </li>
<li id="GUID-EF13F2EF-3703-5E42-B50F-5115A943C649"><p>In EKA2, <codeph>DPhysicalDevice</codeph> is
derived from <codeph>DObject</codeph>. <codeph>DObject</codeph> is new in
EKA2, but has the same reference-counting behaviour as <codeph>CObject</codeph>.
The change is necessary because the kernel no longer has any dependency on
EUSER.DLL. In EKA1, <codeph>DPhysicalDevice</codeph> is derived from <codeph>CObject</codeph>. </p> </li>
</ul> <p id="GUID-27FCEF39-D8EA-5D4D-B897-D8932B7C2687"><b>Changes to DPhysicalDevice::Create()</b> </p> <p> <xref href="GUID-A5484A7F-94B9-34C7-9F88-82B1BF516930.dita#GUID-A5484A7F-94B9-34C7-9F88-82B1BF516930/GUID-B88265CA-0881-3666-BF76-C32E47F9A3A1"><apiname>DPhysicalDevice::Create()</apiname></xref> creates
an interface between the physical and logical devices; this is what is often
referred to as the physical channel. The following list gives a quick summary
of the changes. </p> <ul>
<li id="GUID-A9C3F854-FE03-565B-A828-7742F66007F2"><p>In EKA1, the function
is prototyped as: </p> <codeblock id="GUID-5D2F9FA9-443B-54AF-98AF-4B2ABA6833CD" xml:space="preserve">virtual CBase* CreateL(TInt aUnit,const TDesC* anInfo,const TVersion &amp;aVer) = 0;</codeblock> <p>In EKA2, the function is prototyped as: </p> <codeblock id="GUID-30F70B9C-9E94-5B8F-BC92-9E7EE8BD371A" xml:space="preserve">virtual TInt Create(DBase*&amp; aChannel, TInt aUnit, const TDesC8* aInfo, const TVersion&amp; aVer) = 0;</codeblock> <ul>
<li id="GUID-2D4E9F9A-C950-5EE1-BB2E-9B67B890ED75"><p>The leave mechanism
is no longer available for functions running on the kernel side, and the function
name has therefore been changed to <codeph>Create()</codeph>. </p> </li>
<li id="GUID-5B9488F3-4D94-5C86-8533-1D2B02B55733"><p>In EKA1, a pointer to
the new physical channel object is returned by <codeph>CreateL()</codeph>;
in EKA2, the pointer is returned through the <codeph>DBase*</codeph> reference. </p> </li>
<li id="GUID-9463B745-152D-5C72-ADDF-2E5A2C20DFB3"><p>In EKA1, the physical
channel object is an instance of a class derived from <codeph>CBase</codeph>;
in EKA2, it is an instance of a class derived from <xref href="GUID-4FCB6127-84F3-38F6-8AD2-FC3B94D67DA3.dita"><apiname>DBase</apiname></xref>. </p> </li>
</ul> </li>
<li id="GUID-D380B9F2-9C0F-5F4E-98AF-4740C2A94403"><p>In EKA1, the general
pattern for the implementation of <codeph>CreateL()</codeph> is as follows: </p> <codeblock id="GUID-164C6C56-346F-5111-A397-1717D2C46297" xml:space="preserve">CBase* DDriverPhysicalDevice::CreateL(TInt aUnit,const TDesC* anInfo,const TVersion &amp;aVer)
    {
    DDriver1Device* pD=new(ELeave) DDriver1Device;
    TInt ret = pD-&gt;DoCreateL();
    if (ret != KErrNone)
        {
        delete pD;
        pD = NULL;
        User::Leave(ret);
        }
    return(pD);
    }</codeblock> <p>where <codeph>DDriver1Device</codeph> is the physical
channel class derived from <codeph>CBase</codeph>, and <codeph>DDriverPhysicalDevice</codeph> is
the PDD factory class derived from <xref href="GUID-A5484A7F-94B9-34C7-9F88-82B1BF516930.dita"><apiname>DPhysicalDevice</apiname></xref>. </p> <p>In
EKA2, the general pattern changes to: </p> <codeblock id="GUID-21DB035E-EABA-51F2-9FB1-95BEB8757EE5" xml:space="preserve">TInt DDriverPhysicalDevice::Create(DBase*&amp; aChannel, TInt aUnit, const TDesC8* aInfo, const TVersion&amp; aVer)
    {
    DDriver1Device* device=new DDriver1Device;
    aChannel=device;
    if (!device)
        {
        return KErrNoMemory;
        }
    return device-&gt;DoCreate();
    }
</codeblock> <p>where <codeph>DDriver1Device</codeph> is the physical channel
class derived from <codeph>DBase</codeph> (<b>not from CBase</b>), and <codeph>DDriverPhysicalDevice</codeph> is
the PDD factory class derived from <xref href="GUID-A5484A7F-94B9-34C7-9F88-82B1BF516930.dita"><apiname>DPhysicalDevice</apiname></xref>.. </p> </li>
</ul> <p id="GUID-C35A9FD3-ECBB-556A-8EC6-5F26E6A233CE"><b>Changes to DPhysicalDevice::Validate()</b> </p> <p>This
function is new in EKA2, and does not exist in EKA1. See <xref href="GUID-174CE53D-A9D8-52AD-97C8-7FD8E05BE7DA.dita#GUID-174CE53D-A9D8-52AD-97C8-7FD8E05BE7DA/GUID-BB0BDE33-A73E-5BCB-9338-039215BE8851">Implementing Validate()</xref>. </p> <p id="GUID-D6EE15B9-DF83-5F49-9B2E-1325ACD860D7"><b>Creation of the PDD factory
object</b> </p> <p>This still follows the same pattern as for EKA1. Creating
the factory object is still done through the first exported ordinal function.
The main difference is that you need to use the the macro: <codeph>DECLARE_STANDARD_PDD()</codeph> when
implementing your function. </p> <p>In EKA1: </p> <codeblock id="GUID-3C4FC588-CF97-538A-AF11-E54408AEFEE4" xml:space="preserve">EXPORT_C DPhysicalDevice* CreatePhysicalDevice()
    {
    return new DPhysicalFactory;
    }
      </codeblock> <p>In EKA2: </p> <codeblock id="GUID-85479F4A-0FAB-5DEE-BBE7-68A87340AE3A" xml:space="preserve">DECLARE_STANDARD_PDD()
    {
    return new DPhysicalFactory;
    }
      </codeblock> <p>You need to remove the <codeph>E32Dll()</codeph> function
from your existing code. The code generated by the <codeph>DECLARE_STANDARD_PDD()</codeph> macro,
effectively replaces it. </p> <p>If your driver is a kernel extension, then
you use <codeph>DECLARE_EXTENSION_PDD()</codeph> instead. </p> </section>
<section id="GUID-09386854-74F8-598F-944B-D3C3F62F5C90"><title>Interrupt handling</title> <p>This
is a list of the main changes in interrupt handling, and the EKA2 counterpart
to EKA1. </p> <table id="GUID-8FFC7488-B1E8-55B1-B1A2-AFB82258C7C5">
<tgroup cols="2"><colspec colname="col0"/><colspec colname="col1"/>
<tbody>
<row>
<entry><p> <b>EKA1</b>  </p> </entry>
<entry><p> <b>EKA2</b>  </p> </entry>
</row>
<row>
<entry><p>Interrupts are handled by a class derived from <codeph>TInterrupt</codeph>.
The ISR is an implementation of the pure virtual function <codeph>TInterrupt::Service()</codeph>,
taking a <codeph>TAny</codeph> * parameter. This means that the function is
a member of that derived class. </p> </entry>
<entry><p>The <codeph>TInterrupt</codeph> class has been removed. Instead,
the ISR is just a static function, taking a <codeph>TAny</codeph> *. Usually
this parameter is a pointer to the owning class, but can be used to pass any
32-bit value. </p> </entry>
</row>
<row>
<entry><p>Interrupts are bound by textual names defined in the ASSP layer. </p> </entry>
<entry><p>Interrupts are bound by a number, the interrupt Id that identifes
the interrupt and is provided by the baseport. </p> </entry>
</row>
<row>
<entry><p> <codeph>TInterrupt::Bind()</codeph>  </p> <p>This member function
takes a descriptor holding the name of the interrupt, and optionally a chaining
specifier. </p> </entry>
<entry><p> <xref href="GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3.dita#GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3/GUID-4E3CB472-3525-32F8-9BC4-8ECFEE931E7B"><apiname>Interrupt::Bind()</apiname></xref>  </p> <p>This static function
takes the interrupt Id, the address of the ISR function, and a 32-bit parameter
to pass to the ISR. There is no chaining option because EKA2 does not support
arbitrary ISR chaining. </p> </entry>
</row>
<row>
<entry><p> <codeph>TInterrupt::Unbind()</codeph>  </p> </entry>
<entry><p> <xref href="GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3.dita#GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3/GUID-CCC9A397-608C-3EAF-830F-A59800C2E8E5"><apiname>Interrupt::Unbind()</apiname></xref>  </p> <p>This is now a static
function, part of the static class Interrupt(), and means that you must pass
an an interrupt Id to it. </p> <p> </p> </entry>
</row>
<row>
<entry><p> <codeph>TInterrupt::Enable()</codeph>  </p> </entry>
<entry><p> <xref href="GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3.dita#GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3/GUID-BB169E6E-D8F9-3762-899D-6DBA4B29CF87"><apiname>Interrupt::Enable()</apiname></xref>  </p> <p>This is now a static
function, and means that you must pass an an interrupt Id to it. </p> <p> </p> </entry>
</row>
<row>
<entry><p> <codeph>TInterrupt::Disable()</codeph>  </p> </entry>
<entry><p> <xref href="GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3.dita#GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3/GUID-2D14E023-E6ED-39BF-8B31-6FA510957A8A"><apiname>Interrupt::Disable()</apiname></xref>  </p> <p>This is now a
static function, and means that you must pass an an interrupt Id to it. </p> <p> </p> </entry>
</row>
<row>
<entry><p> </p> </entry>
<entry><p>The <xref href="GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3.dita"><apiname>Interrupt</apiname></xref> class is defined in <codeph>assp.h</codeph>,
and if your code accesses any of its functions, then you will need to include
this header file. </p> <p> </p> </entry>
</row>
</tbody>
</tgroup>
</table> <p><b>Example
interrupt handling code comparing EKA1 with EKA2</b> </p> <p>This is a an
example of a simple EKA1 interrupt handler, and the equivalent EKA2 code.
In this example, the EKA1 code has a major class, <codeph>DMyDeviceDriver</codeph>,
which owns an interrupt service routine encapsulated by a <codeph>TMyInterrupt</codeph> object. </p> <table id="GUID-46D8CAB9-2943-5477-BCEC-2107AC0D5727">
<tgroup cols="1"><colspec colname="col0"/>
<tbody>
<row>
<entry><p> <b>EKA1</b>  </p> </entry>
</row>
<row>
<entry><codeblock id="GUID-3C3888DE-47FB-5376-9A54-7BC3EC104270" xml:space="preserve">class TMyInterrupt : public TInterrupt
    {
public:
    inline TMyInterrupt( DMyDeviceDriver&amp; aOwner ) 
    : iOwner(aOwner) {};
private:
    virtual void Service();
private:
    DMyDeviceDriver&amp;    iOwner;
    };
    </codeblock> <codeblock id="GUID-76585593-7DDF-5E30-8276-707142DE46AD" xml:space="preserve">void TMyInterrupt::Service()
    // This is the ISR, it just
    // calls a function in the
    // owning class
    {
    iOwner-&gt;HandleInterrupt();
    }
    </codeblock> <p>Here, the <codeph>TMyInterrupt</codeph> class provides
only the service routine, which just calls a handler function in the owning
class. There is only a single function here, the ISR itself, and it requires
a pointer to the <codeph>DMyDeviceDriver</codeph> instance. </p> </entry>
</row>
<row>
<entry><p> <b>EKA2</b>  </p> </entry>
</row>
<row>
<entry><p>In EKA2, the <codeph>TMyInterrupt</codeph> class has been removed
and the <codeph>Service()</codeph> member function is turned into a static
function: </p> <codeblock id="GUID-D7E55666-72BC-5D74-B6A1-E60D57E96C7F" xml:space="preserve">LOCAL_C void IntService( TAny* aParam )
    // static interrupt service function
    // aParam points to DMyDeviceDriver instance
    {
    ((DMyDeviceDriver*)aParam)-&gt;HandleInterrupt();
    }
</codeblock> <p>Thus an entire class in EKA1 can be replaced by a single function
under EKA2. </p> </entry>
</row>
</tbody>
</tgroup>
</table> <p>The following code shows the <codeph>DMyDeviceDriver</codeph> class.
For clarity, the purpose of the class is being ignored, as we just want to
concentrate on some of the member functions that manipulate the interrupt.
We don't need to consider the <codeph>HandleInterrupt()</codeph> function
itself because it isn't affected by the EKA2 changes to interrupt handling. </p> <table id="GUID-BBEA8A33-932C-5BF8-B56A-5D0212FC4B92">
<tgroup cols="1"><colspec colname="col0"/>
<tbody>
<row>
<entry><p> <b>EKA1</b>  </p> </entry>
</row>
<row>
<entry><codeblock id="GUID-76677EC6-1683-57AC-87D1-1985DD5166D4" xml:space="preserve">TInt DMyDeviceDriver::BindInterrupt()
    {
    return iMyInterrupt.Bind(_L("Int_Timer"));
    }</codeblock> <p>where <codeph>iMyInterrupt</codeph> would be a <codeph>TInterrupt</codeph> member
or a reference to a <codeph>TInterrupt</codeph>. </p> <codeblock id="GUID-BD48342E-F51B-5406-87F4-0E53C0F48CEB" xml:space="preserve">void DMyDeviceDriver::UnBindInterrupt()
    {
    iMyInterrupt.UnBind();
    }</codeblock> <codeblock id="GUID-B71D88E3-A262-5E38-A53E-1726C7FD18E0" xml:space="preserve">void DMyDeviceDriver::EnableInterrupt()
    {
    iMyInterrupt::Enable();
    }</codeblock> <codeblock id="GUID-F3414F63-07BB-5F5A-B009-FAD00BBA6189" xml:space="preserve">void DMyDeviceDriver::DisableInterrupt()
    {
    iMyInterrupt::Disable();
    }
</codeblock> <codeblock id="GUID-04AB2CC4-C28E-5673-97AA-D04836212507" xml:space="preserve">void DMyDeviceDriver::AcknowledgeInterrupt()
    {
    iMyInterrupt.Clear();    
    }</codeblock> </entry>
</row>
<row>
<entry><p> <b>EKA2</b>  </p> </entry>
</row>
<row>
<entry><codeblock id="GUID-A2EF21E4-7C85-58F4-B61F-95AA66010AA8" xml:space="preserve">TInt DMyDeviceDriver::Bind()
    {
    return Interrupt::Bind(EIntTimer,IntService,this); );
    }
</codeblock> <p>In EKA2, the way that the interrupt is bound changes. The
static ISR function that we created has to be bound to the interrupt and a
pointer to the <codeph>DMyDeviceDriver</codeph> instance passed as a parameter. </p> <p>Note
that the first parameter is now an enum for the interrupt ID instead of a
string. This enum would be provided in a header file. </p> <p>You probably
need to remember whether a device driver channel has actually bound to the
interrupt, otherwise you might accidentally unbind an interrupt that is in
use by a different channel. See <xref href="GUID-396294CF-F666-55DB-BCB3-8E2877AEEC77.dita#GUID-396294CF-F666-55DB-BCB3-8E2877AEEC77/GUID-03A7DE3B-9464-59D3-8A25-FF9A889367B4">Binding
an ISR</xref>. </p> <codeblock id="GUID-AAAF58BE-DCED-5363-BD33-7D687A8D7107" xml:space="preserve">void DMyDeviceDriver::UnBindInterrupt()
    {
    Interrupt.UnBind(EIntTimer);
    }</codeblock> <codeblock id="GUID-5D70964A-44A1-59E5-82E4-578B1C13B10C" xml:space="preserve">void DMyDeviceDriver::EnableInterrupt()
    {
    Interrupt::Enable( EIntTimer );
    }</codeblock> <codeblock id="GUID-30EFE731-EBE9-50BC-93D0-9FC7AA41B65B" xml:space="preserve">void DMyDeviceDriver::DisableInterrupt()
    {
    Interrupt::Disable( EIntTimer );
    }</codeblock> <codeblock id="GUID-5D65668A-67A7-5FDE-84CE-E0A1059AF9E8" xml:space="preserve">void DMyDeviceDriver::AcknowledgeInterrupt()
    {
    Interrupt.Clear( EIntTimer );    
    }</codeblock> </entry>
</row>
</tbody>
</tgroup>
</table> <p>The <codeph>UnBindInterrupt()</codeph>, <codeph>EnableInterrupt()</codeph>, <codeph>DisableInterrupt()</codeph>,
and <codeph>AcknowledgeInterrupt()</codeph> and last four functions easy to
upgrade because each has an equivalent in the EKA2 <xref href="GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3.dita"><apiname>Interrupt</apiname></xref> class. </p> <p><b>Shared interrupts</b> </p> <p>In EKA1, the interrupt framework provides
support for shared interrupts. This is where several peripherals share a single
interrupt line and several ISRs must be called each time that interrupt is
signalled. In EKA1, this is called "chaining", referring to the fact that
the <codeph>TInterrupt</codeph> classes are chained together, being called
one after the other; it is, in fact, an example of sharing. </p> <p>In EKA2,
only one ISR function can be bound to each interrupt. Sharing is still supported
under EKA2 but the concept is slightly different, and is more versatile. An
EKA2 interrupt implementation provides a <i>pseudo-interrupt</i> for each
of the peripherals sharing the true interrupt line. Device drivers then bind
to these pseudo interrupts. Depending on how the interrupt dispatcher is written,
either all the ISRs are called whenever the main interrupt line is signalled,
as in EKA1, or the dispatcher might check the peripherals and call only the
ISR for the peripheral that raised the interrupts. The behaviour is defined
by the baseport, not by Symbian. </p> <p><b>Variant
interrupts</b> </p> <p>EKA1 defined two layers of baseport, the ASSP which
is the core device (for example an Intel XScale) and the Variant, which is
a specific implementation or device based on the core. It is often the case
that the Variant provides extra interrupt sources that are not known to the
core, additional peripheral devices such as PC Card controllers, extra I/O
lines, etc. The EKA1 interrupt architecture is not very good at dealing with
these additional interrupts. Usually you will find that the problem has been
handled so that it is transparent to device drivers, which still use the normal <codeph>TInterrupt</codeph> class,
but occassionally you might find that the variant provides its own interrupt
dispatching functions separate from <codeph>TInterrupt</codeph>. In this case,
you need to convert this to use the standard EKA2 <xref href="GUID-E7A7083C-97B9-39B9-A147-4A6E314EE3A3.dita"><apiname>Interrupt</apiname></xref> functions.
EKA2 can handle an unlimited number of additional interrupt sources all through
the same core API. </p> <p><b>The
keyboard driver as an example of the changes to interrupt handling</b> </p> <p>The
keyboard driver is another example that shows how interrupt handling has changed. </p> <p>(For
reference, the EKA1 source is in <filepath>...\lubbock\vi_keyb.cpp</filepath>,
and the EKA2 source is in <filepath>...\lubbock\specific\keyboard.cpp</filepath>). </p> <p>In
EKA1, the driver functionality is encapsulated by the <codeph>TKeyBoardLubbock</codeph> class.
The interrupt service routine (ISR) is an implementation of the <codeph>Service()</codeph> function,
defined by the abstract class <codeph>TInterrupt</codeph>, and provided by
the <codeph>TKeyboardLubbockInt</codeph> class. The ISR schedules the DFC,
the code being the static <codeph>RxDfc()</codeph> function. </p> <fig id="GUID-377B655C-AC10-5AEE-9483-B9C8E25934ED">
<image href="GUID-5D7D5BE7-2CF9-5592-9111-22EFB21CB5F2_d0e304185_href.png" placement="inline"/>
</fig> <p>In EKA2, there is no <codeph>TInterrupt</codeph> class, and the
ISR must be a static function. In the keyboard driver, it has been renamed
as <codeph>Isr()</codeph>, although the change of name is not necessary. Unlike
in EKA1, the name of the ISR in EKA2 is arbitrary. </p> <fig id="GUID-164C0256-8E4E-50C9-97BE-CB85B46D3BE0">
<image href="GUID-73624CDF-A426-5F1D-9746-AA2D6F62D789_d0e304199_href.png" placement="inline"/>
</fig> <p>Compare the ISR code between the EKA1 version and the EKA2 version. </p> <p>In
EKA1: </p> <codeblock id="GUID-9BE87D5C-C50D-5D66-94BD-20511F51FEA4" xml:space="preserve">void TKeyboardLubbockInt::Service(){
    …
    Disable();        //  disable interrupt, must enable after DFC!
    Clear();        // clear the interrupt
    Kern::Add( *iKeyDfc );    // add the DFC for this interrupt event
    }
</codeblock> <p>In EKA2: </p> <codeblock id="GUID-318757DA-84E9-56D2-895E-A8ED5FA1AD4B" xml:space="preserve">void TKeyboardLubbock::Isr(TAny* aPtr)
    {
    TKeyboardLubbock&amp; k=*(TKeyboardLubbock*)aPtr;
    Interrupt::Disable(EXIntIdTrackRx);
    Interrupt::Clear(EXIntIdTrackRx); 
    k.iRxDfc.Add();
    }
</codeblock> <p>Note: </p> <ul>
<li id="GUID-84334423-F597-5661-A850-ECC6B744F49A"><p>Both versions are as
small and fast as they can possibly be. </p> </li>
<li id="GUID-8EAF1E9C-32FF-5A1A-A57F-9425B3363846"><p>As the EKA2 implementation
of the ISR must be a static function, we need to pass it a pointer to the
keyboard object it should use. In EKA1, this pointer is a member variable
of the <codeph>TKeyboardLubbock</codeph> class. </p> </li>
<li id="GUID-55FE093D-A948-5D6F-9F4C-5FF1B99F09D8"><p>The functions to enable,
disable and clear interrupts are now static member functions of the <codeph>Interrupt</codeph> class.
The interrupt id must now be passed in as an argument to these functions.
The assignment of interrupt Ids depends on the hardware. </p> </li>
<li id="GUID-29FD0DD4-13FE-5ACB-BDDD-FDDA369DC40A"><p>The call to <codeph>Kern::Add()</codeph> has
changed to <codeph>TDfc::Add()</codeph>. In EKA2, the call to add a DFC to
the DFC queue is a member function of the <codeph>TDfc</codeph> class; in
EKA1 it is a static kernel function. </p> </li>
</ul> <p>The driver functionality is encapsulated by the <codeph>TKeyboardLubbock</codeph> class
in both EKA1 and EKA2. It is worth comparing the default constructor for this
class. </p> <p>In EKA1: </p> <codeblock id="GUID-AF7B18F7-42D8-5BE4-BD4A-672C9D429776" xml:space="preserve">TKeyboardLubbock::TKeyboardLubbock():
    iRxDfc( TCallBack( TKeyboardLubbock::RxDfc, this ) ),
    keyup( EFalse ), extended( EFalse ), extended1( EFalse ), 
    prev_scancode( KEYERROR )
    {
    
    __KTRACE_OPT( KBOOT, Kern::Printf( _L( "Keyboard Constructor" ) ) ); 
    
    //setup keyboard keypress interrupt
    iKeyRxInt = new TKeyboardLubbockInt( &amp;iRxDfc, this );        
    
    //Bind the interrupt
    iKeyRxInt-&gt;Bind( _L8(IrqSA1111TpRxInt) );
    }
</codeblock> <p>In EKA2: </p> <codeblock id="GUID-6B5A0217-03D4-5A1C-9B32-978176C178D6" xml:space="preserve">TKeyboardLubbock::TKeyboardLubbock():
    iRxDfc(RxDfc,this,Kern::DfcQue0(),1),
    keyup( EFalse ), extended( EFalse ), extended1( EFalse ), 
    prev_scancode( KEYERROR )
    {
    
    __KTRACE_OPT( KBOOT, Kern::Printf("Keyboard Constructor")); 
    
    //Bind the interrupt
    TInt r=Interrupt::Bind(EXIntIdTrackRx,Isr,this);
    if (r!=KErrNone)
    // panic ??
    ;
    }</codeblock> <p>Note: </p> <ul>
<li id="GUID-6CE1695E-1331-5F17-9270-B414C9486B58"><p>In EKA1, the <codeph>iRxDfx</codeph> member,
a <codeph>TDfc</codeph> type, is initialised with a <codeph>TCallBack</codeph>.
This has changed in EKA2, the DFC object is constructed with the same arguments
as the <codeph>TCallBack</codeph>, but now also requires the DFC queue to
be used and the relative priority of the DFC on that queue, a value in the
range 0..7. </p> </li>
<li id="GUID-1115450A-E162-55AE-8FF8-50F9FBBA70A4"><p>There is no <codeph>TkeyboardInterrupt</codeph> object
in EKA2 – the main <codeph>TKeyboardLubbock</codeph> object now owns the interrupts. </p> </li>
<li id="GUID-FA08B6FE-081E-5BC9-8BCB-304D24E33073"><p>The interrupt binding
is now a static function, and is bound by numeric id, not by a string id as
it is in EKA1. It takes extra parameters for the interrupt service routine
and the keyboard object. </p> </li>
<li id="GUID-EF57B8B5-3094-5F7D-9B4F-1823970C300D"><p>Interrupt binding can
fail in EKA2, e.g. the numeric Id may be out of range, the interrupt may already
be in use. New code needs to be written to deal with possible failure modes. </p> </li>
</ul> <p>This port also shows a number of other changes: </p> <ul>
<li id="GUID-EBE018F2-FDF9-5EEB-A091-C65D5D885A4E"><p> <filepath>e32std.h</filepath> is
not used in EKA2 kernel side code, and <codeph>m32std.h</codeph> does not
exist. To use the <codeph>TDfc</codeph> class in EKA2, include <codeph>kernel.h</codeph>.
In the port of the keyboard, this is included via <filepath>kpower.h</filepath>.
The <codeph>Interrupt</codeph> class declarations are provided via <filepath>platform.h</filepath>. </p> </li>
<li id="GUID-2A94675A-74D8-5961-AAC6-55F8A4BFC822"><p>Other calls to enable/disable/clear
interrupts need to be changed as already mentioned. </p> </li>
<li id="GUID-38C3041E-8F4D-5283-86D5-A342AF2EA99F"><p>In EKA1, the DFC function <codeph>RxDfc()</codeph> returns
a <codeph>TInt</codeph>; it needs to return <codeph>void</codeph> in EKA2. </p> </li>
<li id="GUID-49DC9716-B330-570B-82AC-5D086DECE2A2"><p>Calls to <codeph>Kern::Printf()</codeph> take
a standard C string as an argument in EKA2; in EKA1 the string needs to be
converted into a literal using the <codeph>_L()</codeph> macro. </p> </li>
</ul> <p>In EKA2 there is no interrupt chaining, as is the case in EKA1. If
more than one ISR is required for a particular interrupt source, a first-level
ISR must be bound to that interrupt source, and this must explicitly call
each of the second-level ISRs in the chain. This is implemented by the baseport,
and is transparanet to device driver. See the Base Porting Kit for more information. </p> <p>In
practice, queuing a DFC is the only kernel function that can be called in
an ISR, but it can use helper functions like <codeph>memcpy()</codeph>. Note
that an ISR cannot allocate or free memory, but can access kernel memory -
however be aware of attempts to access memory that might be shared as there
is no synchronisation capability available to an ISR. </p> </section>
<section id="GUID-073716F8-6567-5666-8E37-C6B690178EFC"><title>Kernel-side
code cannot link to EUSER.DLL</title> <p>The kernel no longer has any dependency
on EUSER.DLL. Only user side code can link against EUSER.DLL. There are three
main reasons for this: </p> <ul>
<li id="GUID-1AEAF7CF-B258-5AA5-8135-BA62E5D2EEFB"><p>It allows more robust
on-target application debugging, as it is no longer possible to crash the
kernel by putting an application breakpoint in shared code. </p> </li>
<li id="GUID-13E7E966-8BD3-5C51-B58E-5B24A5AB00A9"><p>It reduces the size
of the minimum system configuration. </p> </li>
<li id="GUID-48F5EA07-80CD-5924-B977-F4104E58976B"><p>It allows the kernel
to be built using a different compiler to that used to build the user side. </p> </li>
</ul> <p>This has important consequences for kernel side code. Any code that
runs on the kernel side, including device drivers, cannot use classes, functionality,
or behaviour that is implemented by EUSER.DLL. For example, classes such as <codeph>HBufC8</codeph>,
are no longer available. You may need to need to write your own equivalent
classes, or use similar classes that exist in the kernel library. There are
some advantages to writing your own classes: they may be more suitable to
your code, or they may be smaller because there's no need for the code to
be generic. </p> <p>While EKA2 does, in fact, provide a replacement for the <codeph>HBufC</codeph> user-side
class in the shape of the <codeph>HBuf</codeph> kernel-side class (NB the
difference in class names), the following code fragments show how you might
approach the task of replacing such functionality yourself. </p> <p>In EKA1: </p> <codeblock id="GUID-E95265AF-7440-5656-856B-BB4296457173" xml:space="preserve">HBufC8* temp=HBufC8::New(MaxSize); 
(temp.Des())-&gt;AppendFill(0, aSize); 
</codeblock> <p>In EKA2, the code can be replaced by using normal C style
pointers and functions: </p> <codeblock id="GUID-7DBF277F-34C8-57FA-9EFF-B1FCAEFC8719" xml:space="preserve">TUint8* buf = Kern::Alloc( MaxSize );
memset( buf, 0, aSize );
</codeblock> <p>The Append &amp; Fill type member functions can be replaced
by <codeph>memset()</codeph>, <codeph>memcpy()</codeph>, <codeph>memcompare()</codeph>, <codeph>wordmove()</codeph>,
as defined in <filepath>nklib.h</filepath> &amp; <filepath>klib.h</filepath>,
and implemented in <codeph>mem.cpp</codeph>. </p> <p>The following code fragments
are an example of replacing HBufC functionality (<i>again remember that HBufC
does have a replacement in the form of HBuf</i>). </p> <p>In EKA1: </p> <codeblock id="GUID-FE9EB90B-A72F-52A9-BEB7-50C60FC7F30D" xml:space="preserve">// allocate buffer of MaxSize bytes on kernel heap
    HBufC8 *temp=HBufC8::New( MaxSize );
    if (temp==NULL)
        return(KErrNoMemory);
    ...
    TUint8* p = temp.Ptr();        // get pointer to buffer
    ...
    TPtr8 pd = temp.Des();        // create descriptor that points to the same buffer
    ...
    TInt s = temp.Size();        // should return MaxSize bytes
    ....
    User::Free(temp);            // free buffer
</codeblock> <p>In EKA2: </p> <codeblock id="GUID-7BB5F900-04B6-548A-8A87-D96E4D9FF35E" xml:space="preserve">    // allocate buffer of MaxSize bytes on kernel heap
    TUint8* Buffer = Kern::Alloc( MaxSize );
    if (Buffer==NULL)
        return(KErrNoMemory);
    ...
    TUint8* p = Buffer;        // use pointer to buffer
    ...
    TInt s = MaxSize;            // use size of Buffer
    ....
    TPtr8 pd(Buffer, MaxSize);    // create descriptor that points to the same buffer
    ...
    TUint8* p = pd.Ptr();        // get pointer to buffer from descriptor
    ....
    TInt s = pd.Size();        // get size from descriptor
    
    Kern::Free(Buffer);        // free buffer
</codeblock> </section>
<section id="GUID-4A7BCB91-C58B-597F-85B6-74463BE9BC04"><title>Accessing User
Memory</title> <p>In EKA1, you access user memory by calling <codeph>Read()</codeph> on
the <codeph>DThread </codeph> object; for example: </p> <codeblock id="GUID-3C43054A-185F-5536-8727-37D45055DAD6" xml:space="preserve">DThread *p;
...
p-&gt;Read( ... );
...</codeblock> <p>In EKA2, you have to use <xref href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.dita#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D/GUID-C505206F-F54F-3760-BA7D-2DB52AB4E0B3"><apiname>Kern::ThreadDesRead()</apiname></xref>, <xref href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.dita#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D/GUID-904A42A8-8077-3FC6-BEF2-29619F079842"><apiname>Kern::ThreadRawRead()</apiname></xref> or
related variants, passing in a pointer to the <codeph>DThread</codeph> object: </p> <codeblock id="GUID-4AE3BE52-6D5E-5041-998D-DC4B552CB13C" xml:space="preserve">DThread *p;
...
Kern::ThreadDesRead(p, ...);
...</codeblock> <p>In EKA1, the functions <codeph>DoControl()</codeph>, <codeph>DoRequest()</codeph>,
and <codeph>DoCancel()</codeph>, implemented in your logical channel class
run in the context of the user side thread. </p> <p>In EKA2, if you use the
framework provided by <codeph>DLogicalChannel</codeph>, the equivalent functionality
runs in a DFC in the context of a kernel-side thread (even if not using this
ready-made framework, but deriving your logical channel directly from <codeph>DLogicalChannelBase</codeph>,
the equivalent functionality is still highly likely to run in the context
of a kernel-side thread). This means that you <i>must</i> use <xref href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.dita#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D/GUID-904A42A8-8077-3FC6-BEF2-29619F079842"><apiname>Kern::ThreadRawRead()</apiname></xref> and <xref href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.dita#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D/GUID-182C88F4-326C-376E-9FBE-889E3CB9B68A"><apiname>Kern::ThreadRawWrite()</apiname></xref> to access user memory. On the other hand, for code that runs in the context
of the user-side client thread, you must use the functions <xref href="GUID-B56A34CD-E5B5-3E3E-A2EE-3BC9D248B210.dita"><apiname>kumemget()</apiname></xref> and <xref href="GUID-C7AB0391-99D5-31A2-91D4-A7F195546FC3.dita"><apiname>kumemput()</apiname></xref>,
or related variants. Also note that if such code is running in a critical
section or holds a fast mutex, calls to these functions must be protected
by XTRAP, a kernel-side exception handler. </p> <p>Note that in EKA1, it is
possible to access user memory directly from the kernel side. However this
is <i>exceedingly bad practice</i> although it does work. In EKA2, you will
not get away with it. </p> <p>See the section <xref href="GUID-C8615948-0CCB-5C4C-BB74-FA66D7028788.dita#GUID-C8615948-0CCB-5C4C-BB74-FA66D7028788/GUID-8CCC6421-E9FD-5E55-AA01-452043C093A6">NEVER
ACCESS USER SPACE DIRECTLY</xref> in <xref href="GUID-C8615948-0CCB-5C4C-BB74-FA66D7028788.dita">Platform
security issues</xref> for more on these functions. </p> <p>See also the <xref href="GUID-8EB25927-D49E-578F-BD93-294C4EECB7E7.dita">Basic APIs</xref> section
in <xref href="GUID-DC8D3736-EDCF-54CB-A614-2AAC4664F1CA.dita">Kernel-Side Services</xref>. </p> </section>
</conbody></concept>