<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies) All rights reserved. -->
<!-- This component and the accompanying materials are made available under the terms of the License 
"Eclipse Public License v1.0" which accompanies this distribution, 
and is available at the URL "http://www.eclipse.org/legal/epl-v10.html". -->
<!-- Initial Contributors:
    Nokia Corporation - initial contribution.
Contributors: 
-->
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept xml:lang="en" id="GUID-55EF3CEB-AF3E-5A32-96F3-F146D1A06C8F"><title>Surface Manager Overview</title><shortdesc>The Surface Manager is responsible for creating graphics composition surfaces (called surfaces) in system memory and controlling access to them. </shortdesc><prolog><metadata><keywords/></metadata></prolog><conbody><p> <b>Variant</b>: <xref href="GUID-D93978BE-11A3-5CE3-B110-1DEAA5AD566C.dita">ScreenPlay</xref>. <b>Target audience</b>: Device creators. </p> <section><title>Summary</title> <p>The Surface Manager creates and manages <xref href="GUID-ADA8CECB-0E70-5B9C-8F36-0714AAF0CD13.dita">graphics composition surfaces</xref>: </p> <ul><li id="GUID-A790AC41-740B-5726-A8AF-7061C4A70398"><p>The Surface Manager allocates memory to which it controls access and that it can safely permit hardware to access. </p> </li> <li id="GUID-DB98578B-105C-5AE7-9BA1-063870D2A07D"><p>The Surface Manager maintains size and format information. </p> </li> <li id="GUID-C3AC5CAD-62EF-55A6-971A-E6C7D48DC8AC"><p>The Surface Manager keeps track of the clients using each surface. </p> </li> </ul> <p>The Surface Manager provides an API that allows clients to <b>create</b>, <b>open</b>, <b>access</b> (map to) and <b>close</b> surfaces. A client can also simply request a surface's attributes. Clients cannot change a surface's attributes which, once the surface has been created, are generally immutable. </p> <p>Surfaces are uniquely identified by a 128 bit <b>surface ID</b>. This comprises eight bits that identify the surface type and 120 bits that identify the surface itself. </p> <p>A client that creates a surface can pass its ID to another process. That process can then become a client of the Surface Manager and use the ID to access the surface. Access to a surface is strictly limited to clients that know the ID. </p> </section> <section><title>Architecture</title> <p>The Surface Manager creates and manages surfaces that are used as input to the composition engine. </p> <fig id="GUID-CDB062F1-36C8-53EA-9603-1680E2000F26"><title>
             Surface Manager and related components 
          </title> <image href="GUID-A021A398-2FD0-5AAA-90B9-418996877600_d0e280852_href.png" placement="inline"/></fig> <p>The Surface Manager is an adaptation component, which means that it can be modified or replaced to suit the exact hardware that is available on a specific device. </p> <p>The Symbian Surface Manager consists of: </p> <ul><li id="GUID-FBE13EEF-D6E7-5D9A-AC7B-B8D05AFEDDDD"><p>A generic DLL that provides the user-side API. This provides features to create and delete surfaces, to access surface pixel data and to query surface attributes. It routes the calls through to the device driver. </p> </li> <li id="GUID-9D528A65-1A06-548F-8CF5-7603932E5910"><p>A reference implementation, which consists of a Logical Device Driver (LDD) and a kernel extension. This implements surfaces as <xref href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.dita">shared chunks</xref>, which allow memory to be mapped into the address space of multiple applications and to be available to hardware such as the MBX GPU. This allows instant access and avoids copying or moving large amounts of data. </p> <p>Shared chunks are memory regions that can be safely shared between user-side and kernel-side processes. The implementation is a kernel extension because shared chunks can only be created by the kernel. As a kernel extension it is controlled using an LDD. It performs shared chunk allocation and allows the client to specify caching attributes. </p> </li> </ul> <fig id="GUID-C33ED56C-4E4D-5A13-BC19-3E723C68A583"><title>
             The Surface Manager reference implementation 
          </title> <image href="GUID-5606802D-7517-5BA5-A3BD-A54C417A1B64_d0e280882_href.png" placement="inline"/></fig> <p>Device creators can replace the reference implementation and retain the user-side API. Alternatively, it is possible to replace both the implementation and the user-side API or to replace the implementation and to extend the user-side API. </p> <p>It is generally necessary to create a custom Surface Manager implementation if hardware-accelerated surfaces (surfaces stored in memory managed by the GPU) are to be used. Device creators can also provide their own APIs on top of the Surface Manager. The following diagram shows the default configuration and two possible adaptation configurations. </p> <fig id="GUID-F1EA4AD3-6711-5FF0-8E79-817F6DD1E02D"><title>
             Some possible Surface Manager configurations 
          </title> <image href="GUID-57372CC6-C7CC-5802-B24C-66A272359968_d0e280894_href.png" placement="inline"/></fig> </section> <section><title>Description</title> <p>Features of the Surface Manager API and reference implementation include: </p> <ul><li id="GUID-58933ADA-DD25-57A6-A263-61CF858A67AF"><p> <b>Cache control</b>  </p> <p>Surface Manager allows cached or uncached operation. If the Memory Management Unit (MMU) supports caching, the client can specify the caching attributes that the Surface Manager is to use for the shared chunk allocation. This enables the Surface Manager to create surfaces in shared chunks that are suitable for both hardware and software renderers. If the MMU does not support the requested caching attribute, a lesser one is used. The client can subsequently query the supported cache behavior. </p> </li> <li id="GUID-C82A0E75-B9AA-59E0-960C-8EC4CF079D94"><p> <b>Chunk adoption</b>  </p> <p>Clients can specify a pre-existing shared chunk when creating surfaces. The shared chunk can originate from an existing surface allocated through the Surface Manager or from another driver. The Surface Manager adopts the chunk passed in instead of allocating new memory. This means that pixel data that has already been written to a shared chunk by, for example, the camera driver, can be used as input to the composition engine. </p> <p>This functionality also allows memory to be saved because one chunk can be used for both landscape and portrait orientations of a surface when both orientations are not required at the same time. </p> </li> <li id="GUID-1B8CE968-1F8A-5BA9-83F6-EDB2912DFCD0"><p> <b>Hinting support</b>  </p> <p>Like metadata, surface hints contain information about surface content. Hints are defined by the device creator and consist of key-value pairs, each of which has a flag that determines whether the value can be changed. Other processes that have access to the surface can read this data and change it if the hint is mutable. They can also add hints after creation of the surface. </p> </li> <li id="GUID-11218802-D733-52E1-8C2E-78ECF48AD4DD"><p> <b>Surface states</b>  </p> <p>The Surface Manager determines the relationship between each client process and each Surface ID. Each process sees each surface ID as being in one of the following states: </p> <ul><li id="GUID-9946AA45-923A-5AFD-8713-62D2B4181E28"><p> <b>Invalid</b>. No surface exists with that ID. </p> </li> <li id="GUID-BDCA4B3B-00F0-5258-A9BB-C5E5D283DB99"><p> <b>Closed</b>. The surface exists, but is not open in the process. </p> </li> <li id="GUID-ED6CCEAF-B11B-5A40-8FF0-598996AC2944"><p> <b>Open</b>. The process has opened the surface. </p> </li> <li id="GUID-88A677B6-0374-5494-9405-59F27A433CE6"><p> <b>Mapped</b>. The process has mapped the surface into its address space. This implies that the surface is open in that process. </p> </li> </ul> <p>Multiple processes that refer to the same surface may have different relationships with that surface. For example, the surface may be mapped in one process but simply open in another process. Most Surface Manager operations require the surface to be in a particular state relative to the calling process. If the surface is not in the required state an error is returned. </p> </li> <li id="GUID-8E5B4474-9D5C-5C7A-94EA-A7CE5F3F5CDF"><p> <b>Reference Counting</b>  </p> <p>The Surface Manager maintains a reference count for each surface. The count is started when the surface is created, gets incremented each time a client calls <codeph>OpenSurface()</codeph> and gets decremented each time <codeph>CloseSurface()</codeph> is called. When the count drops to zero the Surface Manager deletes the surface and releases the memory. </p> <p>When a process exits or closes its session with the Surface Manager, the Surface Manager closes all of the surfaces that the process has open. </p> </li> </ul> </section> <section><title>Executables</title> <p>The Surface Manager component contains the following executable files: </p> <table id="GUID-482D8833-2DA6-579A-8A84-F79AC8BB066A"><tgroup cols="2"><colspec colname="col0"/><colspec colname="col1"/><thead><row><entry>Name</entry> <entry>Description</entry> </row> </thead> <tbody><row><entry><p> <filepath>Surfacemanager.dll</filepath>  </p> </entry> <entry><p>The Surface Manager user-side API, which provides features to create and delete surfaces, to access surface pixel data and to query surface attributes. This routes the calls through to the device driver. </p> </entry> </row> <row><entry><p> <filepath>surfacemanagerdriver.ldd</filepath>  </p> </entry> <entry><p>A system memory logical device driver and kernel extension. It performs shared chunk allocation and allows the client to specify caching attributes. </p> </entry> </row> </tbody> </tgroup> </table> </section> <section><title>Typical uses</title> <p>Typical use involves creating a surface, querying its properties and passing the surface ID to another process. A second process can then open the surface. </p> <p>Clients of the Surface Manager simply create an instance of the client side class <xref href="GUID-733B8BFA-7BC2-3A6D-A66F-F788413D25A9.dita"><apiname>RSurfaceManager</apiname></xref> and use its API. The complexities of device driver communication, memory management and thread safety are completely encapsulated. </p> <codeblock id="GUID-821CBBD0-C966-5720-960E-28F2A01CEEE2" xml:space="preserve">RSurfaceManager surfaceManager;
surfaceManager.Open();
...
// Surface Manager now ready for use</codeblock> <p><b>Creating a surface </b> </p> <p>Before creating a surface, you specify its attributes through the <xref href="GUID-455B9D45-0BB4-3B1B-831E-B7CF5D050BB9.dita"><apiname>TSurfaceCreationAttributes</apiname></xref> class. </p> <codeblock id="GUID-7E5F2756-1F39-5241-86A8-879F29E0E6E6" xml:space="preserve">class TSurfaceCreationAttributes
    {
    public:
    TSize iSize;                    // Width/height in pixels
    TInt iBuffers;                  // Number of buffers in the surface
    TUidPixelFormat iPixelFormat;   // Pixel format 
    TInt iStride;                   // Number of bytes between start of one line and start of next
    TInt iOffsetToFirstBuffer;      // Reserve space before the surface pixel data
    TInt iAlignment;                // Buffer alignment. 1,2,4,8 byte aligned
    TBool iContiguous;              // Whether you want physically contiguous memory
    TCacheAttribute iCacheAttrib;   // Caching attributes
    TInt iOffsetBetweenBuffers;     // Offset from start of one buffer and start of next in bytes
    THintPair* iSurfaceHints;       // Array of hints associated with the surface
    TInt iHintCount;                // Number of hints in the array
    TBool iMappable;                // Whether the surface should be mappable
    };</codeblock> <p>When the Surface Manager creates a surface, it creates an ID for the surface and passes it back to the client. The client then uses the ID to refer to the surface. The client can pass the ID to other applications or processes which can then use it to gain access to the surface through the Surface Manager. </p> <p>For an example of creating a surface, see <xref href="GUID-E238B1FE-BBD8-5C6D-AE04-258188EFF9FF.dita">Creating a Graphics Surface Tutorial</xref>. </p> <p><b>Accessing a Surface </b> </p> <p>The following code fragment illustrates how a second client can access an existing surface once it has the ID. </p> <codeblock id="GUID-91D2EAC5-FC9F-5658-A161-F0230809623F" xml:space="preserve">
RSurfaceManager surfaceManager;
surfaceManager.Open();
    
RChunk chunk;
    
surfaceManager.OpenSurface(surfaceId);
surfaceManager.MapSurface(surfaceId, chunk);
    
// retrieve surface information
RSurfaceManager::TInfoBuf infoBuf;
RSurfaceManager::TSurfaceInfoV01&amp; surfaceInfo = infoBuf();   
    
surfaceManager.SurfaceInfo(surfaceId, surfaceInfo);
    
...
    
// tidy up.</codeblock> <p>The fragment also illustrates how to get information about a surface's attributes. </p> </section> </conbody><related-links><link href="GUID-ADA8CECB-0E70-5B9C-8F36-0714AAF0CD13.dita"><linktext>Graphics Surfaces</linktext> </link> <link href="GUID-0DC3E5AA-1706-5255-ACD6-E7AB732E1095.dita"><linktext>Graphics Composition Collection Overview</linktext> </link> <link href="GUID-E238B1FE-BBD8-5C6D-AE04-258188EFF9FF.dita"><linktext>Creating a Graphics
                Surface Tutorial</linktext> </link> <link href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.dita"><linktext>Shared Chunks</linktext> </link> <link href="GUID-0437DB4C-FC4E-51DC-BB4C-95C0B26834F5.dita"><linktext>Device Driver Guide</linktext> </link> </related-links></concept>