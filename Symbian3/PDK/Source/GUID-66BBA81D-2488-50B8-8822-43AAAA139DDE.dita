<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies) All rights reserved. -->
<!-- This component and the accompanying materials are made available under the terms of the License 
"Eclipse Public License v1.0" which accompanies this distribution, 
and is available at the URL "http://www.eclipse.org/legal/epl-v10.html". -->
<!-- Initial Contributors:
    Nokia Corporation - initial contribution.
Contributors: 
-->
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="GUID-66BBA81D-2488-50B8-8822-43AAAA139DDE" xml:lang="en"><title>Overview
of random number generation</title><prolog><metadata><keywords/></metadata></prolog><conbody>
<section id="GUID-B5BD3E1A-AFBB-5526-B5EA-8FA51A17E596"><title>Overview</title> <p>The
purpose of the Random Number Generation API is the generation of cryptographically
strong random numbers. </p> <p>Several cryptographic applications rely upon
the randomness, unpredictability and irreproducibility of the random number
generator, such as: </p> <ul>
<li id="GUID-15685756-F94B-508C-A08C-8F0ECBC1A4AA"><p>one-time pads </p> </li>
<li id="GUID-7E3ED7CE-65C3-5E8B-9FF0-139763F3E54B"><p>key generation </p> </li>
<li id="GUID-0C65E7E4-A3F5-5EC4-9851-4A4E3090607B"><p>random nonces </p> </li>
<li id="GUID-3C16304A-CDA0-5F50-9D6C-D76C2D6EA586"><p>Initialization Vectors
(IVs) </p> </li>
<li id="GUID-59F195DE-94E7-56EE-9A7D-EAB5E401DF9A"><p>salts to be hashed with
passwords </p> </li>
<li id="GUID-96B7B9D1-AB0D-5A54-9C7F-771008F354C1"><p>unique parameters in
signing operations. </p> </li>
</ul> <p>The RNG uses the <xref href="http://www.agner.org/random/" scope="external">RANROT</xref> algorithm
seeded by random data available on the target hardware (for instance free
running counters available on ARM processors). <note><p>In order to be <b>fully</b> compliant
with DSS (Digital Signature Standard), applications using the cryptography
library must supply a <xref href="http://cr.yp.to/bib/2000/-dss.pdf" scope="external">FIPS-186-2</xref> CR
1 compliant random number generator. The library provides a mechanism for
using such a random number generator if required. </p></note></p> </section>
<section id="GUID-9350FD0E-7F09-5D82-BB91-EC1C8D740DBD"><title>The Random
Number Generation API</title> <p>The diagram below shows the main classes
used in the RNG, which are implemented in <filepath>random.dll</filepath>.
For information on each class see the Cryptography API Reference material. </p> <fig id="GUID-5326D881-8795-5803-8B82-EC02C0C40226">
<title>              The inheritance hierarchy for the RRandomSession and
CSystemRandom classes            </title>
<image href="GUID-FD1BB5C6-A042-56C9-8F1F-B51BF9DF5389_d0e615621_href.png" placement="inline"/>
</fig><p><b>How to use TRandom</b> </p> <p> <codeph>TRandom</codeph> is a
cryptographically stong random number generator. Its declaration is: </p> <codeblock id="GUID-53D847C3-2A1A-51D8-93FA-F68EA2374551" xml:space="preserve">class TRandom
    {
public:
    IMPORT_C static void RandomL(TDes8&amp; aDestination);
    };</codeblock><note> The function <codeph>TRandom::Random()</codeph> which
panics rather than leaves when it cannot obtain a random number, is deprecated
from v9.1 onwards. </note> <p> <codeph>TRandom::RandomL()</codeph> generates
random bytes by first connecting to the random number generation server (using <codeph>RRandomSession</codeph>).
If the attempt to connect fails, <codeph>TRandom::RandomL()</codeph> leaves. </p> <p>The
server fills <codeph>aDestination</codeph> with randomly generated bytes up
to its current length (not its maximum length). If this fails, <codeph>TRandom::RandomL()</codeph> leaves.
If <codeph>aDestination</codeph> is 1024 or more bytes long, multiple calls
are made to the server. Finally, <codeph>TRandom</codeph> closes the session. </p> <p> <codeph>TRandom</codeph> can
be used like this: </p> <codeblock id="GUID-0472582C-D5BD-520D-848E-9989E8730851" xml:space="preserve">HBufC8* rand = HBufC8::NewLC(5);
TPtr8 pRand=rand-&gt;Des();
pRand.SetLength(5);
TRandom::RandomL(pRand);
...
CleanupStack::PopAndDestroy(rand);</codeblock> </section>
</conbody></concept>