<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies) All rights reserved. -->
<!-- This component and the accompanying materials are made available under the terms of the License 
"Eclipse Public License v1.0" which accompanies this distribution, 
and is available at the URL "http://www.eclipse.org/legal/epl-v10.html". -->
<!-- Initial Contributors:
    Nokia Corporation - initial contribution.
Contributors: 
-->
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="GUID-33D93E96-98A9-4116-9028-3241D76A1036" xml:lang="en"><title>Enabling
additional touch events for your application</title><shortdesc>The Symbian platform provides additional touch events to enable
drag events using <parmname>CCoeControl::EnableDragEvents()</parmname>and
to specify screen areas for touch events.</shortdesc><prolog><metadata><keywords/></metadata></prolog><conbody>
<p>By default, the Symbian platform sends only <parmname>EButton1Up</parmname> and <parmname>EButton1Down</parmname> touch
events to applications.</p>
<p>If you want to enable <parmname>EDrag</parmname> touch events, implement <parmname>CCoeControl::EnableDragEvents()</parmname> in
your container class.</p>
<p>When the mobile device user drags the stylus on the screen, <codeph>TPointerEvent::EDrag()</codeph> events
are sent. When dragging stops, the application receives the event <codeph>TPointerEvent::EButton1Up()</codeph>.</p>
<codeblock xml:space="preserve">void CTableauControl::ConstructL( const TRect&amp; aRect )
    {
    // This is parent window
    CreateWindowL();

    EnableDragEvents();

    //SetRect( aRect );
    SetExtentToWholeScreen();
    
    
    // Initialize component array
    InitComponentArrayL();
    
    
	 //Implement your own logic here
  	 ActivateL();
    }</codeblock>
<p>It is enough that the container control set <codeph>EnableDragEvents()</codeph> in
its construction. <codeph>EnableDragEvents()</codeph> need not be set again
for the child controls to receive dragging events.</p>
<section id="GUID-7B30F0D5-1EAE-4F40-B04F-6A3953BCC634"><title>Controlling
which control receives a touch event</title><p>Particularly when you are receiving
drag events it may be that an object in the window may be drawn by one control,
while the pointer is over another control. In cases where you want to ensure
that pointer events are received by the intended control, implement <parmname>CCoeControl::SetPointerCapture()</parmname>.</p><p>When
a control receives a <parmname>TPointerEvent::EButton1Down()</parmname> event,
all events will be sent to this control until the next <parmname>TPointerEvent::EButton1Up()</parmname> event.
If you want to have events to be sent to another control before the <parmname>TPointerEvent::EButton1Up()</parmname> event,
call <codeph>SetPointerCapture(ETrue)</codeph> from the new control. </p><p>When
the new control has received its pointer event and <parmname>TPointerEvent::EButton1Up()</parmname> has
been received, you have to call <codeph>SetPointerCapture(EFalse)</codeph> from
the new control to stop events being sent to it indefinitely.</p></section>
<section id="GUID-8C337F8B-346A-430A-9A7A-A48B53031421"><title>Specifying
screen areas for touch events</title><p>To specify screen areas (<codeph>TRect</codeph>)
for touch events, see the example below.</p><codeblock xml:space="preserve">void CTableauControl::HandlePointerEventL(const TPointerEvent&amp; aPointerEvent)
    {
    // Does the user point exit text on screen? 
    // iExitRect is rectangle of the text area on screen.
    if (iExitRect.Contains(aPointerEvent.iPosition))
        {
        if (iEikonEnv-&gt;QueryWinL(_L("Klondike"),_L("Exit?")))
            {
            // Exit was pointed, then do exit   
            (static_cast&lt;CKlondikeAppUi*&gt;(iEikonEnv-&gt;AppUi()))-&gt;HandleCommandL(EEikCmdExit);
            return;
            }
        }
    ...
    }</codeblock></section>
<section id="GUID-8B12AF1C-A98A-416D-A586-807CFC2B839D"><title>Ignoring events
other than pointer up in your control</title><p>In cases where you want to
make sure your control receives only touch <parmname>EButton1Up</parmname> events
after receiving a touch <parmname>EButton1Down</parmname> event, implement <parmname>CCoeControl::IgnoreEventsUntilNextPointerUp()</parmname>. </p></section>
</conbody></concept>