<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies) All rights reserved. -->
<!-- This component and the accompanying materials are made available under the terms of the License 
"Eclipse Public License v1.0" which accompanies this distribution, 
and is available at the URL "http://www.eclipse.org/legal/epl-v10.html". -->
<!-- Initial Contributors:
    Nokia Corporation - initial contribution.
Contributors: 
-->
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept xml:lang="en" id="GUID-E6E6A439-B3CC-5FEA-9148-2DB5F37003F2"><title>Creating an Extended Bitmap Rasterizer</title><shortdesc>An extended bitmap rasterizer is a DLL that decompresses extended bitmaps in order that they can be drawn by using the legacy BitGDI API. </shortdesc><prolog><metadata><keywords/></metadata></prolog><conbody><p> <b>Variant</b>: <xref href="GUID-D93978BE-11A3-5CE3-B110-1DEAA5AD566C.dita">ScreenPlay</xref> and <xref href="GUID-F64E6551-670E-5E12-8103-DE504D3EC94F.dita">non-ScreenPlay</xref>. <b>Target audience</b>: Device creators. </p> <p>This topic assumes an understanding of the material covered in <xref href="GUID-D76C7759-739D-5C98-B718-7297687FE630.dita">Extended Bitmaps</xref>. </p> <section><title>Introduction</title> <p>The standard <xref href="GUID-71DADA82-3ABC-52D2-8360-33FAEB2E5DE9.dita">Font and Bitmap Server</xref> client library (<filepath>fbscli.dll</filepath>) dynamically links against the extended bitmap rasterizer DLL. </p> <p>When an application calls <xref href="GUID-E5B29AC0-4953-385F-84C5-13EE6CB77D46.dita#GUID-E5B29AC0-4953-385F-84C5-13EE6CB77D46/GUID-2CFBA1CE-BD31-3AC8-BA6B-14263FE26545"><apiname>RFbsSession::Connect()</apiname></xref> to create a session with the Font and Bitmap Server, an instance of the extended bitmap rasterizer DLL is instantiated in the context of the application thread. This extended bitmap rasterizer DLL instance is used by the thread in which it is created and it is destroyed when the <xref href="GUID-E5B29AC0-4953-385F-84C5-13EE6CB77D46.dita"><apiname>RFbsSession</apiname></xref> is closed. Multiple threads across the system can simultaneously use their own extended bitmap rasterizer DLL instances. </p> <p>BitGDI uses the extended bitmap rasterizer DLL through the Font and Bitmap Server client-side library to obtain scan lines from extended bitmaps as if they are compressed bitmaps. </p> </section> <section><title>Implementing the CFbsRasterizer interface</title> <p>An extended bitmap rasterizer DLL must provide an implementation of the <xref href="GUID-FFA11F49-C802-3476-BDF6-41222A800F80.dita"><apiname>CFbsRasterizer</apiname></xref> interface. This interface provides BitGDI with APIs for rasterizing extended bitmaps and retrieving scan lines from them. The following table provides a brief description of the key functions. For more detailed documentation, see <xref href="GUID-FFA11F49-C802-3476-BDF6-41222A800F80.dita"><apiname>CFbsRasterizer</apiname></xref>. </p> <table id="GUID-95F0E9E6-28CE-5E6E-BE0E-27CF1BE38046"><tgroup cols="2"><colspec colname="col0"/><colspec colname="col1"/><thead><row><entry>Function</entry> <entry>Description</entry> </row> </thead> <tbody><row><entry><p> <codeph>New()</codeph>  </p> </entry> <entry><p>Returns a new instance of the extended bitmap rasterizer DLL for use by the calling thread. </p> </entry> </row> <row><entry><p> <codeph>BeginBitmap()</codeph>  </p> </entry> <entry><p>Registers an extended bitmap with the extended bitmap rasterizer DLL so that scan line requests can be made on that bitmap. <codeph>BeginBitmap()</codeph> is a signal to the extended bitmap rasterizer DLL that scan lines are about to be requested for a particular extended bitmap. It is therefore an opportunity for the extended bitmap rasterizer DLL to pre-rasterize all of the extended bitmap or the requested region of it. This makes it possible to return a portion of the pre-rasterized bitmap quickly when <codeph>ScanLine()</codeph> is subsequently called. Because <codeph>ScanLine()</codeph> is often called repeatedly, pre-rasterizing the bitmap at the <codeph>BeginBitmap()</codeph> stage can improve performance considerably. </p> </entry> </row> <row><entry><p> <codeph>EndBitmap()</codeph>  </p> </entry> <entry><p>Unregisters an extended bitmap that was previously registered using <codeph>BeginBitmap()</codeph>. <codeph>EndBitmap()</codeph> allows any resources that were allocated for the extended bitmap to be released. However, you may want to implement a cache of the most recently used extended bitmaps. This can improve performance of applications that make multiple calls to <xref href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.dita#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB/GUID-D24300BA-20D7-34E6-BD23-ED281A0D957E"><apiname>CFbsBitmap::GetScanLine()</apiname></xref>, <xref href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.dita#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB/GUID-838CF3C5-C513-33B7-9C81-0EBCE075F6B7"><apiname>CFbsBitmap::GetPixel()</apiname></xref> or <xref href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.dita#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB/GUID-57BC8EB1-B9F4-39A9-A18B-594CFB7786B6"><apiname>CFbsBitmap::GetVerticalScanLine()</apiname></xref>. See <xref href="GUID-E6E6A439-B3CC-5FEA-9148-2DB5F37003F2.dita#GUID-E6E6A439-B3CC-5FEA-9148-2DB5F37003F2/GUID-A1A50E3D-5037-5558-9099-8CD8C28B9FBC">Performance considerations</xref> below for more information. </p> </entry> </row> <row><entry><p> <codeph>ScanLine()</codeph>  </p> </entry> <entry><p>Returns a scan line of pixels for a particular extended bitmap. The scan lines must be 32-bit aligned. Although an x-coordinate and length are passed in, <codeph>ScanLine()</codeph> must return a pointer to the start of the whole scan line. However, only the portion defined by the x-coordinate and the length need to contain correct data. </p> <p>The first call to <codeph>ScanLine()</codeph> from BitGDI for an extended bitmap is always preceded by a call to <codeph>BeginBitmap()</codeph>. </p> </entry> </row> <row><entry><p> <codeph>GetInterface()</codeph>  </p> </entry> <entry><p>Returns a pointer to an extension interface. This provides a mechanism for extending the <xref href="GUID-FFA11F49-C802-3476-BDF6-41222A800F80.dita"><apiname>CFbsRasterizer</apiname></xref> interface without breaking existing implementations. If the extended bitmap rasterizer DLL does not support any extended interfaces, this function must return <codeph>KErrExtensionNotSupported</codeph>. </p> </entry> </row> </tbody> </tgroup> </table> </section> <section><title>Error handling</title> <p>It is important that your extended bitmap rasterizer DLL is robust and does not cause any exceptions or panics, because a copy is loaded for each Font and Bitmap Server session. When the extended bitmap rasterizer DLL encounters an error, it must fail silently in order to avoid causing a system failure. </p> <p>When testing your extended bitmap rasterizer DLL using the <xref href="GUID-4A501086-7EFF-376D-8901-6D9B2EB4EFF2.dita"><apiname>CFbsBitGc</apiname></xref> blitting and drawing operations, you will see a white rectangle drawn if an error occurs in the extended bitmap rasterizer DLL. BitGDI draws a white scan line when a scan line cannot be retrieved from the extended bitmap rasterizer DLL. </p> </section> <section id="GUID-A1A50E3D-5037-5558-9099-8CD8C28B9FBC"><title>Performance considerations</title> <p><b>Caching </b> </p> <p>Adding a cache of previously rasterized extended bitmaps to your extended bitmap rasterizer DLL might improve performance significantly, especially for applications that make repeated calls to <xref href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.dita#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB/GUID-D24300BA-20D7-34E6-BD23-ED281A0D957E"><apiname>CFbsBitmap::GetScanLine()</apiname></xref>, <xref href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.dita#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB/GUID-838CF3C5-C513-33B7-9C81-0EBCE075F6B7"><apiname>CFbsBitmap::GetPixel()</apiname></xref> or <xref href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.dita#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB/GUID-57BC8EB1-B9F4-39A9-A18B-594CFB7786B6"><apiname>CFbsBitmap::GetVerticalScanLine()</apiname></xref>. The following pseudocode shows what happens when an application calls <xref href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.dita#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB/GUID-D24300BA-20D7-34E6-BD23-ED281A0D957E"><apiname>CFbsBitmap::GetScanLine()</apiname></xref> repeatedly for an extended bitmap: </p> <codeblock id="GUID-1C00C5A6-79CB-52D5-A0A8-618A2E421F7B" xml:space="preserve">for each (scanline)
    {
    BeginBitmap() 
    ScanLine()
    EndBitmap()
    }
</codeblock> <p>In contrast, when drawing an extended bitmap using <xref href="GUID-4A501086-7EFF-376D-8901-6D9B2EB4EFF2.dita#GUID-4A501086-7EFF-376D-8901-6D9B2EB4EFF2/GUID-F9B06D87-AB42-3A94-AF00-8879D28A866B"><apiname>CFbsBitGc::BitBlt()</apiname></xref> or <xref href="GUID-4A501086-7EFF-376D-8901-6D9B2EB4EFF2.dita#GUID-4A501086-7EFF-376D-8901-6D9B2EB4EFF2/GUID-24606804-DE19-3F87-8A45-0FC031F4300E"><apiname>CFbsBitGc::DrawBitmap()</apiname></xref>, the sequence is as follows: </p> <codeblock id="GUID-545102E0-5C88-5627-96F2-EDC392635464" xml:space="preserve">BeginBitmap()
for each (scanline)
    {
    ScanLine()
    }
EndBitmap()
</codeblock> <p>If the extended bitmap rasterizer DLL has a cache of previously rasterized extended bitmaps, calls to <xref href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.dita#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB/GUID-D24300BA-20D7-34E6-BD23-ED281A0D957E"><apiname>CFbsBitmap::GetScanLine()</apiname></xref>, <xref href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.dita#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB/GUID-838CF3C5-C513-33B7-9C81-0EBCE075F6B7"><apiname>CFbsBitmap::GetPixel()</apiname></xref> and <xref href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.dita#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB/GUID-57BC8EB1-B9F4-39A9-A18B-594CFB7786B6"><apiname>CFbsBitmap::GetVerticalScanLine()</apiname></xref> do not need to rasterize the bitmap for each call, which can improve performance dramatically. </p> <p>An extended bitmap rasterizer DLL cache contains the previously rasterized content for the most recently used extended bitmaps. Typically the extended bitmap rasterizer DLL adds new bitmaps to the cache when <xref href="GUID-FFA11F49-C802-3476-BDF6-41222A800F80.dita#GUID-FFA11F49-C802-3476-BDF6-41222A800F80/GUID-64CF1808-1B05-3403-AB3F-D002F3A4AAFC"><apiname>CFbsRasterizer::BeginBitmap()</apiname></xref> is called (if they are not already in the cache) and does not automatically remove bitmaps from the cache when <xref href="GUID-FFA11F49-C802-3476-BDF6-41222A800F80.dita#GUID-FFA11F49-C802-3476-BDF6-41222A800F80/GUID-23EB43C0-1694-39BE-AEFF-1E4ADA30E765"><apiname>CFbsRasterizer::EndBitmap()</apiname></xref> is called. </p> <p>It is possible for an extended bitmap to be deleted before its cached information is deleted from the cache. It is therefore important that the cache does not store pointers to the data that was used to create the pre-rasterized content. </p> <p>There are two approaches that can be used to manage the cache: </p> <ul><li id="GUID-7233E700-FF1D-5FD9-985C-F0FB40643003"><p>Remove the oldest items when a maximum cache size is reached. </p> </li> <li id="GUID-AA32ADA2-6AED-51F2-B7CB-39DA24288F6D"><p>Associate the extended bitmap rasterizer DLL with a <xref href="GUID-6EAFEB3B-D5F1-3CAE-A9F3-5955F891F122.dita"><apiname>CIdle</apiname></xref> active object and remove all of the items during idle times. </p> </li> </ul> <p>It is recommended that you use both mechanisms in order to optimize memory usage. The example extended bitmap rasterizer DLL does this. It maintains a list of recently used bitmaps, with the most recently used one being first in the list. If the size of the cache exceeds the set maximum, the oldest bitmaps are removed until the size is within limits again. The example extended bitmap rasterizer DLL also uses a <xref href="GUID-6EAFEB3B-D5F1-3CAE-A9F3-5955F891F122.dita"><apiname>CIdle</apiname></xref> object that clears the cache during idle times. </p> <p><b>Memory </b> </p> <p>The example extended bitmap rasterizer DLL allocates and frees memory during <xref href="GUID-FFA11F49-C802-3476-BDF6-41222A800F80.dita#GUID-FFA11F49-C802-3476-BDF6-41222A800F80/GUID-64CF1808-1B05-3403-AB3F-D002F3A4AAFC"><apiname>CFbsRasterizer::BeginBitmap()</apiname></xref> and <xref href="GUID-FFA11F49-C802-3476-BDF6-41222A800F80.dita#GUID-FFA11F49-C802-3476-BDF6-41222A800F80/GUID-23EB43C0-1694-39BE-AEFF-1E4ADA30E765"><apiname>CFbsRasterizer::EndBitmap()</apiname></xref>, respectively. This approach may be slow if frequent allocation and freeing of large amounts of memory is required. </p> <p>A possible solution is to pre-allocate a memory pool from which the extended bitmap rasterizer DLL can use areas of memory. This reduces the number of allocations. However, this solution may be unsuitable for some scenarios, such as when memory usage is more important than performance. </p> </section> <section><title>Example extended bitmap rasterizer</title> <p>The Symbian platform provides a simple example extended bitmap rasterizer, which you can use as a reference when you are creating your own. The source code is located in the <filepath>os\graphics\fbs\fontandbitmapserver\trasterizer\src</filepath> folder. It is built as <filepath>fbsrasterizer_test.dll</filepath> when you build the test code for the Font and Bitmap Server component. </p> <p>This extended bitmap rasterizer DLL handles a tricolor flag. The data comprises the flag's three colors and the direction (horizontal or vertical) of the stripes as shown in the following picture. </p> <fig id="GUID-1EEEB83A-984C-528A-BC5D-5B17836EAA29"><title>
             Tricolor flag with horizontal and vertical stripes 
          </title> <image href="GUID-538302A3-F4B2-539C-8048-39E6028CB2A2_d0e234305_href.png" placement="inline"/></fig> <ul><li id="GUID-01B79E41-BC48-5BCD-B613-D220BCCF0F48"><p>When <xref href="GUID-FFA11F49-C802-3476-BDF6-41222A800F80.dita#GUID-FFA11F49-C802-3476-BDF6-41222A800F80/GUID-64CF1808-1B05-3403-AB3F-D002F3A4AAFC"><apiname>CFbsRasterizer::BeginBitmap()</apiname></xref> is called for this type of extended bitmap, the extended bitmap rasterizer DLL creates a pixel buffer the size of the whole flag and draws the flag into it. If BitGDI specifies a region, the extended bitmap rasterizer DLL draws only the region and otherwise it draws the whole flag. For some extended bitmap rasterizers it may be faster to ignore the region and draw the whole bitmap area. </p> </li> <li id="GUID-9E19CB56-56E4-58FD-A4BD-F3F03305C4AE"><p>Calls to <xref href="GUID-FFA11F49-C802-3476-BDF6-41222A800F80.dita#GUID-FFA11F49-C802-3476-BDF6-41222A800F80/GUID-6C2BF4A4-86D1-3489-BA3D-2145E0077705"><apiname>CFbsRasterizer::ScanLine()</apiname></xref> return a pointer to the appropriate place in the pre-rasterized buffer. </p> </li> <li id="GUID-E336F19A-3172-5E7C-82C1-E65968D5F4FB"><p>Calling <xref href="GUID-FFA11F49-C802-3476-BDF6-41222A800F80.dita#GUID-FFA11F49-C802-3476-BDF6-41222A800F80/GUID-23EB43C0-1694-39BE-AEFF-1E4ADA30E765"><apiname>CFbsRasterizer::EndBitmap()</apiname></xref> causes the pre-rasterized buffer to be stored in the cache or deleted. </p> </li> </ul> </section> <section><title>Packaging the DLL</title> <p>Because an extended bitmap rasterizer DLL is optional, there is a stub implementation for platform security reasons. When a functional extended bitmap rasterizer DLL is not present, the stub implementation is compiled into a DLL and is installed in the ROM in order to prevent a SIS file installing a rogue DLL with the same name. </p> <p><b>The MMP file </b> </p> <ul><li id="GUID-36A2ABAB-C2B6-519E-85CC-155D56A0E985"><p>The DLL must have the name <filepath>fbsrasterizer.dll</filepath>. If the DLL is renamed during the build process, use the <codeph>LINKAS</codeph> keyword in the MMP file to indicate that this is the final name of the DLL. See <xref href="GUID-946E64D6-3E5D-5264-AD5D-29D3AD296543.dita">Selection of Adaptations</xref> for more information. </p> </li> <li id="GUID-5A5D9A8A-60BD-53F0-B8EB-1CAA1E841C88"><p>Use UIDs 0x1000008D (which indicates a static interface DLL) and 0x10285EAE (which is a unique identifier that indicates that this is an extended bitmap rasterizer DLL). </p> </li> <li id="GUID-0BDEDB09-7118-5822-A27C-4391EB04FA26"><p>The DLL must have all capabilities except TCB (Trusted Computing Base). </p> </li> <li id="GUID-B32F0BA1-5832-57C6-A864-32405357B5C4"><p>Use the <codeph>NOEXPORTLIBRARY</codeph> keyword to prevent the generation of LIB/DSO files during the build process. </p> </li> </ul> <p>Here is a snippet from the stub implementation's MMP file: </p> <codeblock id="GUID-9A970A60-4DE3-58F7-A353-F86777929181" xml:space="preserve">TARGET fbsrasterizer_stub.dll
TARGETTYPE DLL
CAPABILITY All -Tcb
UID 0x1000008D 0x10285EAE
LINKAS fbsrasterizer.dll
NOEXPORTLIBRARY</codeblock> <p><b>ROM building </b> </p> <p>Building a ROM image for a target platform involves using IBY files. By default the stub implementation is included using the standard mechanism for selecting graphics adaptation components. This is described in <xref href="GUID-946E64D6-3E5D-5264-AD5D-29D3AD296543.dita">Selection of Adaptations</xref>. </p> <p>There is no generic IBY file for the extended bitmap rasterizer. Instead it is included in the main <filepath>fbserv.iby</filepath> file like this: </p> <codeblock id="GUID-9D326323-7148-573E-A792-FD3517047CED" xml:space="preserve">// FBSERV_IBY
    
#ifndef __FBSERV_IBY__
#define __FBSERV_IBY__
    
REM FBSERV - Font and Bitmap Server
    
...
    
// Extended bitmap rasterizer DLL
#include &lt;graphics_adaptation.hby&gt;
#include FBSRASTERIZER_DRV
      
#endif //__FBSERV_IBY__</codeblock> <p>You must create an implementation-specific IBY file. This should have a unique name of the form <filepath>fbsrasterizer_vendor.iby</filepath>, where <filepath>vendor</filepath> is the vendor's name, the format of the proprietary data or some other identifying feature of the extended bitmap rasterizer DLL. Here is an example of an implementation-specific IBY file: </p> <codeblock id="GUID-0D7FF35E-91E1-591F-BC32-3138D969A8AF" xml:space="preserve">// FBSRASTERIZER_VENDOR_IBY
    
#ifndef FBSRASTERIZER_VENDOR_IBY
#define FBSRASTERIZER_VENDOR_IBY
    
file=ABI_DIR\BUILD_DIR\fbsrasterizer_vendor.dll \sys\bin\fbsrasterizer.dll
    
#endif // FBSRASTERIZER_VENDOR_IBY
</codeblock> <p>This IBY file must be exported to the <filepath>/epoc32/rom/include/core/os/</filepath> folder. </p> <p>You can include this implementation-specific IBY file in a device ROM configuration file by adding the following line to a top-level OBY file like this: </p> <codeblock id="GUID-DAA65C8C-301B-5CDB-B804-90FC35AB4711" xml:space="preserve">#define FBSRASTERIZER_DRV &lt;fbsrasterizer_vendor.iby&gt;</codeblock> <p>This is the preferred method. However, an alternative is to specify the IBY on the BUILDROM command line like this: </p> <codeblock id="GUID-42C88366-7CB9-55F3-BBB7-0A0EA4B46DA8" xml:space="preserve">BUILDROM ... â€“DFBSRASTERIZER_DRV="^&lt;"fbsrasterizer_vendor.iby"^&gt;" ... 
</codeblock> <p>Notice that the ^ character is used as an escape character for the &lt; and &gt; characters. </p> <p>See <xref href="GUID-946E64D6-3E5D-5264-AD5D-29D3AD296543.dita">Selection of Adaptations</xref> for more information. </p> <p><b>The emulator </b> </p> <p>By default, an extended bitmap rasterizer DLL is not included on the emulator (WINSCW). To include your extended bitmap rasterizer DLL for testing on the emulator add the following line to your <filepath>epoc.ini</filepath> file: </p> <codeblock id="GUID-A56861AB-AF5E-52AD-A961-2D454EA548B8" xml:space="preserve">FBSRASTERIZER_DLL &lt;your_rasterizer_dll_name&gt;</codeblock> </section> </conbody><related-links><link href="GUID-D76C7759-739D-5C98-B718-7297687FE630.dita"><linktext>Extended Bitmaps</linktext> </link> <link href="GUID-71DADA82-3ABC-52D2-8360-33FAEB2E5DE9.dita"><linktext>Font and Bitmap Server Overview</linktext> </link> </related-links></concept>