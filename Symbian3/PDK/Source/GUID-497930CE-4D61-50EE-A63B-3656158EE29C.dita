<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies) All rights reserved. -->
<!-- This component and the accompanying materials are made available under the terms of the License 
"Eclipse Public License v1.0" which accompanies this distribution, 
and is available at the URL "http://www.eclipse.org/legal/epl-v10.html". -->
<!-- Initial Contributors:
    Nokia Corporation - initial contribution.
Contributors: 
-->
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept xml:lang="en" id="GUID-497930CE-4D61-50EE-A63B-3656158EE29C"><title>Thin Templates</title><prolog><metadata><keywords/></metadata></prolog><conbody><p>Symbian platform C++ uses C++ templates in an efficient way called the thin template idiom. </p> <p>Templates are particularly useful for collection classes, such as arrays. The class declaration: </p> <codeblock id="GUID-ACAAAE20-4A81-5C4F-930B-31097FBAD432" xml:space="preserve">class CArrayFixFlat&lt;T&gt; ...</codeblock> <p>specifies a family of array classes, which may contain any type. The template may be instantiated, for instance, as </p> <codeblock id="GUID-D02E8C13-85FA-5DA2-8A5E-5F1C15F4038C" xml:space="preserve">CArrayFixFlat&lt;CCoeControl*&gt;* iControls;</codeblock> <p>which declares an array of <codeph>CCoeControl*</codeph> pointers. Other collection classes use the same idea, for instance <codeph>TPckgBuf&lt;T&gt;</codeph>, <codeph>TSglQue&lt;T&gt;</codeph> etc. </p> <p>Templates may also use other parameters, such as an integer: </p> <codeblock id="GUID-209E8594-EFC2-5F55-AF45-51CE538C1336" xml:space="preserve">class TBufC&lt;TInt S&gt; ...;</codeblock> <p>This type of template class may be instantiated also: </p> <codeblock id="GUID-5ABEBD1D-1B0A-5C57-B35E-260180F31978" xml:space="preserve">TBufC&lt;20&gt; name; </codeblock> <p>The functionality provided by templates is powerful, and highly desirable. Without templates, collection classes usually use <codeph>void*</codeph> pointers: as a result, they are not typesafe. </p> <p>Templates can be difficult to manage. A template really defines a whole family of classes. Each member of that family that is instantiated requires its own object code. Avoidance of object code duplication is a difficult issue in a C++ implementation. For the Symbian platform, object code duplication must be avoided at all costs. The solution used is the <i>thin template idiom</i>. </p> <p>The thin template idiom begins with a base class, code in terms of <codeph>TAny*</codeph> parameters: </p> <codeblock id="GUID-C6ADB9B7-4290-5A6B-B1B4-7D9C88E90B1F" xml:space="preserve">class CArrayFixBase ... {
    IMPORT_C const TAny* At(TInt aIndex) const;</codeblock> <p>This base class has the real code, just once. The code resides in a single DLL and is exported from that DLL. The base class may be fat: it may contain an arbitrary amount of code. </p> <p>Then, a derived class is used as follows: </p> <codeblock id="GUID-58361D84-0D13-5E9B-936F-1D4724A71282" xml:space="preserve">class CArrayFix&lt;T&gt; : public CArrayFixBase {
    inline const T&amp; At(TInt aIndex) const
    {return(*((const T *)CArrayFixBase::At(anIndex)));}</codeblock> <p>Because this class uses only inline functions, it generates no extra code. But because the casting is encapsulated in the inline function, the class is typesafe to its users. The templated class is thin: it generates no code at all. </p> </conbody></concept>